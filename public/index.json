[
{
	"uri": "http://localhost:1313/7-setting-up-sandbox/7.1-configure-aws-credentials/",
	"title": "Configure AWS Credentials",
	"tags": [],
	"description": "",
	"content": "Setup AWS CLI with SSO Authentication Configure AWS CLI to use the IAM Identity Center credentials for sandbox deployment and management.\nAccess AWS Identity Center Portal Navigate to your AWS Access Portal URL from the previous step. Sign in with your amplify-admin credentials. Click on your AWS account to access the credential options. Get Access Credentials Click on Command line or programmatic access. Select your operating system (Windows, macOS, or Linux). Copy the SSO configuration details displayed. Initial AWS Configuration First, run the basic AWS configuration command:\naws configure This will prompt for basic AWS configuration.\nConfigure AWS CLI Profile Open a terminal in your project directory and run:\naws configure sso Enter the following information when prompted:\nSSO session name: amplify-admin SSO start URL: Your AWS Access Portal URL SSO region: Your AWS region (e.g., ap-southeast-1) SSO registration scopes: Leave blank (press Enter) Complete SSO Authorization The CLI will provide a verification URL and code. Open the URL in your browser and enter the verification code. Click Allow access to authorize the CLI. After authorization, you\u0026rsquo;ll be redirected to the Amplify app for confirmation. Select Account and Role Choose your AWS account from the list. Select the appropriate role (should show the amplify-policy permission set). Set the CLI default client Region to your preferred region. Set the CLI default output format to json or leave blank. Set Profile Name When prompted for the profile name, use:\namplify-admin Do not use \u0026ldquo;default\u0026rdquo; as the profile name. Use \u0026ldquo;amplify-admin\u0026rdquo; to avoid conflicts with existing AWS configurations and ensure proper credential isolation.\nVerify Configuration Test your configuration by running:\naws sts get-caller-identity --profile amplify-admin You should see your account information, confirming the credentials are working correctly.\nAdd Session Token (If Required) In some cases, you may need to add an AWS session token manually:\nNavigate to Users/\u0026lt;Username\u0026gt;/.aws/credentials on your system. Open the credentials file in a text editor. Add the session token to the end of your profile section: [amplify-admin] aws_access_key_id = YOUR_ACCESS_KEY aws_secret_access_key = YOUR_SECRET_KEY aws_session_token = YOUR_SESSION_TOKEN The session token is typically only required if you encounter authentication issues during sandbox deployment.\nResult Your AWS CLI is now configured with SSO authentication and ready for sandbox deployment.\n"
},
{
	"uri": "http://localhost:1313/4-deploy-the-application-via-aws-amplify/4.1-connect-github-to-amplify/",
	"title": "Connect GitHub to Amplify",
	"tags": [],
	"description": "",
	"content": "Access AWS Amplify Console To deploy your application, you need to connect your GitHub repository to AWS Amplify for continuous deployment.\nNavigate to Amplify Service Open the AWS Management Console and search for Amplify. Click on AWS Amplify to access the service. Click Deploy an App or Create New App to start the deployment process. Select Source Provider On the \u0026ldquo;Start building with Amplify\u0026rdquo; page, choose GitHub as the source provider. Click Continue to proceed with GitHub integration. Authorize GitHub Access If prompted, log in to your GitHub account. Authorize AWS Amplify to access your GitHub repositories. Grant the necessary permissions for repository access. Select Repository and Branch From the dropdown menu, select your leftover repository. Choose the main branch for deployment. Verify that the correct repository and branch are selected. Ensure you select the correct repository and branch that contains your Vite React application with the Amplify configuration.\nConfirm Repository Connection Review the selected repository and branch settings. Click Next to proceed to the build settings configuration. Result Your GitHub repository is now connected to AWS Amplify and ready for build configuration in the next step.\n"
},
{
	"uri": "http://localhost:1313/11-monitoring-with-cloudwatch/11.1-create-cloudwatch-dashboard/",
	"title": "Create CloudWatch Dashboard",
	"tags": [],
	"description": "",
	"content": "Setting up a CloudWatch dashboard provides centralized monitoring for your Bedrock application metrics and costs.\nNavigate to CloudWatch Console Open the AWS Management Console and search for CloudWatch In the CloudWatch console, navigate to Dashboards in the left sidebar Click Create Dashboard to begin setup Configure Dashboard Settings Dashboard Name: Enter leftover-dashboard Click Create Dashboard to proceed to widget configuration The dashboard creation wizard will open automatically Initial Widget Setup The dashboard is now ready for widget configuration. You\u0026rsquo;ll be prompted to add your first widget with the following default options:\nData source type: CloudWatch Data type: Metrics Widget type: Line Result Your CloudWatch dashboard foundation is now established and ready for Bedrock metrics configuration. The next step will focus on adding specific monitoring widgets for token usage and invocation tracking.\n"
},
{
	"uri": "http://localhost:1313/2-initialize-and-push-to-github/2.1-create-github-repository/",
	"title": "Create GitHub Repository",
	"tags": [],
	"description": "",
	"content": "Access GitHub Account To host your project remotely and enable AWS service integration, you need to create a GitHub repository for version control and deployment.\nNavigate to Repository Creation Log in to your GitHub account at github.com. Click on your profile avatar in the top-right corner. Select New or click the + icon and choose New repository. Configure Repository Settings Set up the repository with the following configuration:\nRepository name: leftover\nUse a descriptive name that matches your project Visibility: Choose Public or Private based on your preference\nPublic repositories are accessible to everyone Private repositories require access permissions Initialize options: Leave unchecked for now\nWe\u0026rsquo;ll push existing code from the local project Create Repository Review your repository settings. Click Create repository to finalize the creation. GitHub will display the repository page with setup instructions. Copy Repository URL Copy the HTTPS repository URL from the quick setup section. The URL format will be: https://github.com/your-username/leftover.git Keep this URL ready for the next step where you\u0026rsquo;ll connect your local project. The repository URL is essential for connecting your local Git repository to the remote GitHub repository. Keep it accessible for the next step.\nResult Your GitHub repository is now created and ready to receive your local project files.\n"
},
{
	"uri": "http://localhost:1313/13-setup-iam-role-for-lambda/13.1-create-iam-role/",
	"title": "Create IAM Role",
	"tags": [],
	"description": "",
	"content": "Access IAM Console To create an IAM role for Lambda functions, you need to navigate to the IAM service within the AWS Management Console.\nNavigate to IAM Roles Go to the AWS Management Console and search for IAM in the services search bar. Click on IAM to access the Identity and Access Management console. In the left navigation panel, click on Roles. Start Role Creation Click Create role to begin the role creation process. This will open the role configuration wizard. Select Trusted Entity Choose AWS Service as the trusted entity type. Select Lambda from the use case options. This configuration allows Lambda functions to assume this role. Result You have successfully configured the basic role settings and are ready to add permissions in the next step.\n"
},
{
	"uri": "http://localhost:1313/14-create-lambda-function-for-data-collection/14.1-create-lambda-function/",
	"title": "Create Lambda Function",
	"tags": [],
	"description": "",
	"content": "Access Lambda Console To create a Lambda function for data collection, you need to navigate to the Lambda service within the AWS Management Console.\nNavigate to Lambda Console Go to the AWS Management Console and search for Lambda in the services search bar. Click on Lambda to access the Lambda console. Click Create function to start the function creation process. Configure Function Settings Set up the basic configuration for your Lambda function:\nFunction name: leftover-data-collector\nUse a descriptive name that identifies the function\u0026rsquo;s purpose Runtime: Node.js 22.x\nSelect the latest Node.js runtime for optimal performance Architecture: x86_64\nChoose the standard x86_64 architecture Configure Execution Role Execution role:\nSelect Use an existing role option. Choose LeftoverDataCollectionRole from the dropdown. This role provides the necessary permissions for S3 access and basic execution. Using the existing role ensures your Lambda function has the proper permissions to write data to the S3 bucket and execute with CloudWatch logging.\nCreate the Function Review all configuration settings to ensure they match the requirements. Click Create function to finalize the creation process. Result Your Lambda function leftover-data-collector is now created and ready for code implementation in the next step.\n"
},
{
	"uri": "http://localhost:1313/1-setting-up-vite/1.1-create-vite-project/",
	"title": "Create Vite Project",
	"tags": [],
	"description": "",
	"content": "Initialize Development Environment To begin building the leftover ingredients application, you need to set up a modern development environment using Vite with React and TypeScript.\nCreate Project Directory Open Visual Studio Code or your preferred code editor. Create a new folder for your project workspace. Open a terminal in the project directory. Generate Vite Project Execute the following command to create a new Vite project:\nnpm create vite@latest leftover -- --template react-ts -y This command performs the following actions:\nCreates a new project named leftover Uses the React + TypeScript template Automatically confirms all prompts with the -y flag Vite provides fast build times and hot module replacement (HMR) for an optimal development experience with modern React features and TypeScript support.\nVerify Project Structure After successful creation, you should see:\nProject folder leftover with all necessary files Package.json with React, TypeScript, and Vite dependencies Basic project structure with src/, public/, and configuration files Result Your Vite project is now scaffolded and ready for development server startup in the next step.\n"
},
{
	"uri": "http://localhost:1313/6-setup-iam-identity-center/6.1-enable-iam-identity-center/",
	"title": "Enable IAM Identity Center",
	"tags": [],
	"description": "",
	"content": "Access IAM Identity Center Service To set up centralized access management, you need to enable AWS IAM Identity Center in your AWS account.\nNavigate to IAM Identity Center Open the AWS Management Console and search for IAM Identity Center. Click on IAM Identity Center to access the service. You\u0026rsquo;ll see the IAM Identity Center dashboard with setup options. Enable IAM Identity Center Click Enable to start the IAM Identity Center setup process. This will initiate the configuration wizard for your organization. Configure with AWS Organizations A popup will appear with setup options. Select Enable with AWS Organizations for integrated management. Click Continue to proceed with the organization-based setup. Enabling with AWS Organizations provides centralized management across multiple AWS accounts and simplifies permission management for your organization.\nComplete Basic Setup IAM Identity Center will configure the basic infrastructure. Wait for the setup process to complete. You\u0026rsquo;ll see confirmation that IAM Identity Center is now enabled. Verify Setup After enabling, you should see:\nIAM Identity Center dashboard with management options Access to Users, Groups, and Permission sets Integration with AWS Organizations (if applicable) Ready status for user and permission configuration Result IAM Identity Center is now enabled and ready for user and permission configuration in the next step.\n"
},
{
	"uri": "http://localhost:1313/3-setting-up-amplify/3.1-initialize-amplify-project/",
	"title": "Initialize Amplify Project",
	"tags": [],
	"description": "",
	"content": "Access Project Directory To set up AWS Amplify for your application, you need to initialize it within your existing Vite project directory.\nNavigate to Project Root Ensure you are in the leftover project directory. Open a terminal or command prompt in the project root. Verify you can see the package.json and other project files. Initialize Amplify Execute the following command to create a new Amplify project:\nnpm create amplify@latest -y This command performs the following actions:\nDownloads and installs the latest Amplify CLI tools Creates the basic Amplify project structure Sets up configuration files for AWS resource management Automatically confirms all prompts with the -y flag The Amplify initialization creates a foundation for integrating AWS services like authentication, APIs, storage, and hosting into your application.\nVerify Project Structure After successful initialization, you should see:\nA new amplify/ directory in your project root Amplify configuration files and folders Backend environment settings and resource definitions Check Amplify Directory The amplify/ directory contains:\nBackend configuration files Resource definitions for AWS services Environment-specific settings Deployment configurations Result Your project now has AWS Amplify initialized and is ready for backend service configuration and version control in the next step.\n"
},
{
	"uri": "http://localhost:1313/5-setting-up-frontend-and-backend/5.1-install-dependencies-and-setup-frontend/",
	"title": "Install Dependencies and Setup Frontend",
	"tags": [],
	"description": "",
	"content": "Install Required Dependencies To integrate AWS Amplify with your React application, you need to install the necessary libraries and UI components.\nNavigate to Project Directory Open a terminal in your leftover project directory. Ensure you\u0026rsquo;re in the root folder where package.json is located. Install Amplify Libraries Execute the following command to install AWS Amplify dependencies:\nnpm install aws-amplify @aws-amplify/ui-react This command installs:\naws-amplify: Core Amplify library for AWS service integration @aws-amplify/ui-react: Pre-built React UI components for authentication and other features Configure Base Styling Update the src/index.css file with improved styling:\n:root { font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif; line-height: 1.5; font-weight: 400; color: rgba(255, 255, 255, 0.87); font-synthesis: none; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; max-width: 1280px; margin: 0 auto; padding: 2rem; } .card { padding: 2em; } .read-the-docs { color: #888; } .box:nth-child(3n + 1) { grid-column: 1; } .box:nth-child(3n + 2) { grid-column: 2; } .box:nth-child(3n + 3) { grid-column: 3; } Setup Application Styling Update the src/App.css file with component-specific styles:\n.app-container { margin: 0 auto; padding: 20px; text-align: center; } .header-container { padding-bottom: 2.5rem; margin: auto; text-align: center; max-width: 48rem; } .main-header { font-size: 2.25rem; font-weight: bold; color: #1a202c; } .main-header .highlight { color: #2563eb; } @media (min-width: 640px) { .main-header { font-size: 3.75rem; } } .description { font-weight: 500; font-size: 1.125rem; max-width: 65ch; color: #1a202c; } These styles provide a clean, responsive design foundation for your application with proper typography and layout structure.\nResult Your project now has the necessary Amplify dependencies installed and basic styling configured for the frontend interface.\n"
},
{
	"uri": "http://localhost:1313/",
	"title": "Leftover – Creating a Smart Recipe Generator Website using Amazon Bedrock AI",
	"tags": [],
	"description": "",
	"content": "Leftover – Creating a Smart Recipe Generator Website using Amazon Bedrock AI Overview Leftover suggests a new direction that integrates the latest cloud-native technologies. Vite + React + TypeScript is utilized for fast and modular frontend development, where AWS Amplify enables easy hosting, continuous deployment, and infrastructure management.\nLooking ahead, the project also involves integrating AWS Bedrock, a robust foundation model service. With Bedrock, the application will be capable of integrating generative AI capabilities such as text generation, summarization, and intelligent search—without requiring teams to grapple with advanced machine learning infrastructure. This forward-thinking integration opens the door to a smarter, more responsive web application experience.\nBy combining rapid development tooling with scalable cloud and next-generation AI capabilities, this project addresses both the short-term pain points and long-term innovation opportunities.\nGoals Build and launch a modern web app using cloud technology and prepare it for future AI features. The goal is to replace old file-sharing tools with something faster, smarter, and more user-friendly—both for users and developers.\nKey Objectives:\nMake Frontend Development Fast and Smooth Use React, TypeScript, and Vite to build the app quickly and keep the code clean and modular. Add features like hot module reload so developers can see changes instantly.\nDeploy Automatically and at Scale Use AWS Amplify to handle app hosting and create a deployment pipeline.\nConnect with GitHub so changes go live through a smooth CI/CD process.\nGet Ready for AI Integration Design the system so that it\u0026rsquo;s easy to plug in AI services (like AWS Bedrock) later.\nThis will allow features like smart search, AI-generated content, and insight automation in the future.\nFollow Cloud Best Practices Use modern DevOps techniques (automation, caching, config files) to keep things fast and efficient.\nMake sure the app runs well at scale and is easy for developers to work with.\nWork Together Securely and Smoothly Let multiple developers contribute safely using GitHub + Amplify environments.\nMake deployment steps repeatable and easy for long-term success and growth.\nScope This is a project to create a modern, smart, and scalable web application using cloud-native frameworks and technologies. The scope covers everything from environment setup to deployment as well as future readiness for integration with AI through AWS Bedrock.\nIn Scope:\nFrontend Development: Develop the application interface using React + TypeScript and Vite for fast development and high performance. Cloud Infrastructure Integration: Configure and initialize AWS Amplify for deployment, hosting, and management of CI/CD pipeline. Customize Amplify’s amplify.yml for build and deployment automation. Source Control \u0026amp; Repository Management: Set up and manage the GitHub repository with commit history, branch handling, and integration with Amplify. Build and Deployment Process: Configure build artifacts, cache directories, and deploy the application to a live domain using Amplify Hosting. Support automatic redeployment via GitHub commits. AI-Ready Architecture: Design project structure to be compatible with future AWS Bedrock integration for embedding generative AI features. Out of Scope:\nBackend API Development: Custom backend APIs and logic are not implemented in this phase, other than as introduced via Amplify defaults. Full AWS Bedrock Integration: Although the project is configured for AI integration, actual Bedrock services (i.e., text generation, embeddings) are not activated during this workshop phase. Production-Grade Security \u0026amp; Access Control: There is no complex access control, authentication, or fine-grained security roles in the project yet. Complex Multi-Environment Configurations: The Scope is a single environment deployment (i.e., main branch to Amplify hosting). Solution Architecture This architecture shows how a web app and a developer interact with a secure AI system hosted on AWS Cloud.\nFor Users:\nA user accesses the app via a web browser.\nAWS Cognito verifies identity and gives secure credentials.\nAWS Amplify hosts the React frontend.\nFrontend uses AppSync (GraphQL) to talk to backend services.\nAI Request Flow:\nAppSync sends a request to the Invoke Agent Handler (Lambda).\nThis handler talks to either Region-1 or Region-2 AI models.\nEach region has inference profiles that choose a specific AI model to run.\nThe model returns a result which flows back to the frontend.\nFor Developers:\nDevelopers access AWS services through IDE.\nIAM Identity Center gives access and credentials.\nThey use a Sandbox environment for safe testing.\nData Handling: Requests to API Gateway can:\nTrigger Lambda functions for storage\nUse IAM to get permission\nStore data in S3 bucket\nAnalyze it via Amazon Athena\nShared Tools: AWS tools like CDK, CloudFormation, CloudTrail, CLI, CloudWatch help with development, monitoring, and deployment.\nStructure Diagram Requirements For the Workshop Main Content Creating a new AWS Account Setting up MFA for the AWS Account root user Creating an Administrator Accounts and Groups Getting support for Account Authentication "
},
{
	"uri": "http://localhost:1313/12-s3-bucket-for-data-storage/12.1-navigate-to-s3-console/",
	"title": "Navigate to S3 Console",
	"tags": [],
	"description": "",
	"content": "Access the S3 Service To begin creating your S3 bucket, you need to navigate to the S3 service within the AWS Management Console.\nNavigate to S3 Console Go to the AWS Management Console and search for S3 in the services search bar. Click on S3 to access the Simple Storage Service console. Start Bucket Creation Once you\u0026rsquo;re in the S3 console:\nClick Create bucket to start the bucket creation process. This will open the bucket configuration page where you can specify your bucket settings. Result You are now ready to configure your S3 bucket settings in the next step.\n"
},
{
	"uri": "http://localhost:1313/9-setting-up-amazon-bedrock-cross-region/9.1-request-cross-region-model-access/",
	"title": "Request Cross-Region Model Access",
	"tags": [],
	"description": "",
	"content": "Access Amazon Bedrock Console Similar to the legacy approach, you need to request model access, but this time for Claude 4 Sonnet with cross-region inference capabilities.\nNavigate to Model Catalog Open the AWS Management Console and search for Amazon Bedrock. Click on Amazon Bedrock to access the service. Navigate to Model Catalog in the left sidebar. Select Claude 4 Sonnet Model Browse the available models in the catalog. Locate Claude 4 Sonnet from Anthropic. Note that this model supports cross-region inference. Claude 4 Sonnet is available in ap-southeast-1 region and supports cross-region inference, providing automatic failover and load balancing across multiple regions.\nRequest Model Access Choose your preferred access method:\nEnable All Models:\nEnables access to all foundation models in the region No charges until models are actually used Can be harder to manage and track usage Enable Specific Models (Recommended):\nSelect only Claude 4 Sonnet for better control Easier to track usage and manage permissions More cost-effective approach Configure Model Access Select Claude 4 Sonnet from the available models list. Review the model details and cross-region capabilities. Complete any required use case information for Anthropic models. Click Submit to request access. Access Cross-Region Interface After model approval, navigate to Cross-Region Inference. You\u0026rsquo;ll find the inference profile ARN and available regions. Note the Inference Profile ID for later configuration. Verify Cross-Region Setup Confirm Claude 4 Sonnet is available with cross-region support. Copy the Inference Profile ID (e.g., apac.anthropic.claude-sonnet-4-20250514-v1:0). Note the supported regions for automatic routing. The cross-region inference profile automatically handles region selection and failover, eliminating the need to manually configure multiple regional endpoints.\nResult You now have Claude 4 Sonnet access with cross-region inference capabilities, ready for backend configuration.\n"
},
{
	"uri": "http://localhost:1313/8-setting-up-amazon-bedrock-legacy/8.1-request-model-access/",
	"title": "Request Model Access",
	"tags": [],
	"description": "",
	"content": "Access Amazon Bedrock Console To use Amazon Bedrock models, you need to request access to specific foundation models in your AWS account.\nNavigate to Model Catalog Open the AWS Management Console and search for Amazon Bedrock. Click on Amazon Bedrock to access the service. Navigate to Model Catalog in the left sidebar. Select Claude 3.5 Sonnet Model Browse the available models in the catalog. Locate Claude 3.5 Sonnet from Anthropic. Click on the model to view its details. Claude 3.5 Sonnet is readily available in the ap-southeast-1 region. Check the AWS documentation for model availability in different regions.\nRequest Model Access You have two options for enabling model access:\nEnable All Models:\nClick Modify model access and select all available models. This enables access to all foundation models in the region. Cost: No charges apply until you actually use the models. Management: Can be harder to manage and track which models are being used. Enable Specific Models:\nClick Enable specific model to choose individual models. Select only the models you need (recommended approach). Cost: Only pay for models you actually invoke. Management: Easier to track usage and manage permissions. For this workshop, we recommend Enable Specific Models and select only Claude 3.5 Sonnet to maintain better control and visibility over your model usage.\nConfigure Model Access Select Claude 3.5 Sonnet from the available models list. Review the model details and pricing information. For Anthropic models, you\u0026rsquo;ll be prompted to provide use case details. Provide Use Case Details When requesting access to Anthropic models, fill in the required information:\nCompany Information:\nCompany Name: Your organization or personal project name Company Website URL: Use your deployed Amplify application URL Industry: Select the most appropriate category for your use case Use Case Description:\nPrimary Use Case: Recipe generation and cooking assistance Description: AI-powered application that suggests recipes based on available ingredients Expected Usage: Development and testing purposes for educational workshop Click Submit to request access after completing the form. Wait for Approval The model access request will be processed. You\u0026rsquo;ll see a status indicating the request is being reviewed. Wait for the approval process to complete. Verify Access Once approved, you should see:\nModel status showing as \u0026ldquo;Available\u0026rdquo; or \u0026ldquo;Enabled\u0026rdquo; Ability to invoke the model through API calls Access to model configuration options Result You now have access to Claude 3.5 Sonnet in your primary region and can proceed to set up the fallback region.\n"
},
{
	"uri": "http://localhost:1313/1-setting-up-vite/",
	"title": "Setting Up Vite Development Environment",
	"tags": [],
	"description": "",
	"content": "Content:\nCreate Vite Project Run Development Server Vite is a next-generation frontend build tool that provides fast development server and optimized builds. In this section, we\u0026rsquo;ll set up a React + TypeScript project using Vite for our leftover ingredients application.\nCreate Vite Project Initialize a new Vite project with React and TypeScript template. Configure the project structure and dependencies. Verify the project scaffolding is complete. Run Development Server Navigate to the project directory and install dependencies. Start the development server with hot module replacement. Access the application and verify it\u0026rsquo;s running correctly. "
},
{
	"uri": "http://localhost:1313/10-create-the-website-frontend/10.1-setup-assets-and-logo/",
	"title": "Setup Assets and Logo",
	"tags": [],
	"description": "",
	"content": "Create Project Assets Structure Organize your project files by creating a proper folder structure for images and other assets.\nCreate Assets Directory Navigate to the src/ folder in your project. Create a new folder named assets. Inside the assets folder, create another folder named pics. The folder structure should look like:\nsrc/ ├── assets/ │ └── pics/ │ └── logo.png (to be added) ├── App.tsx ├── App.css └── index.css Add Custom Logo For this project, we\u0026rsquo;ve created a custom logo for aesthetic purposes and branding.\nDownload and Place Logo Download the provided logo.png file from: Download Logo Place the logo.png file inside the src/assets/pics/ directory. Ensure the file is named exactly logo.png for proper import. You can use your own custom logo by replacing the provided logo.png file, or remove the logo entirely by modifying the App.tsx component in the next step.\nVerify File Structure After adding the logo, your project structure should include:\nsrc/assets/pics/logo.png Proper folder hierarchy for organized asset management Easy access for importing in React components Logo Specifications The logo should ideally be:\nFormat: PNG with transparent background Size: Approximately 150x150 pixels or similar square dimensions Style: Clean and simple design that works well with the application theme Result Your project now has a proper assets structure with a custom logo ready for integration into the main application component.\n"
},
{
	"uri": "http://localhost:1313/3-setting-up-amplify/3.2-commit-changes-to-git/",
	"title": "Commit Changes to Git",
	"tags": [],
	"description": "",
	"content": "Save Amplify Configuration After initializing Amplify, you need to commit the new configuration files to version control to track changes and enable team collaboration.\nStage Amplify Files Add all the new Amplify-related files to Git staging:\ngit add . This command stages all new files and directories created by the Amplify initialization, including:\nThe amplify/ directory and its contents Configuration files Any updated package files Create Commit Create a descriptive commit message for the Amplify setup:\ngit commit -m \u0026#34;Add AWS Amplify setup and configuration\u0026#34; This commit captures the current state of your project with Amplify initialized.\nPush to GitHub Push the changes to your remote GitHub repository:\ngit push Verify Repository Update Navigate to your GitHub repository in the browser. Refresh the page to see the new commits. Verify that the amplify/ directory appears in the repository. Project Structure Confirmation Your project now includes:\nOriginal Vite + React + TypeScript files Git version control with GitHub integration AWS Amplify configuration and backend setup Complete project history tracked in version control Result Your project is now successfully configured with AWS Amplify and all changes are committed to version control, providing:\nBackend service integration capabilities Proper version control of Amplify configurations Team collaboration support through GitHub Foundation for AWS resource deployment Always commit Amplify configuration changes to maintain consistency across development environments and enable proper deployment workflows.\n"
},
{
	"uri": "http://localhost:1313/5-setting-up-frontend-and-backend/5.2-configure-authentication-and-backend/",
	"title": "Configure Authentication and Backend",
	"tags": [],
	"description": "",
	"content": "Implement Authentication Wrapper Configure the application to use AWS Amplify\u0026rsquo;s authentication system with the Authenticator component.\nUpdate Main Entry Point Replace the content of src/main.tsx with the following code:\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom/client\u0026#34;; import App from \u0026#34;./App.jsx\u0026#34;; import \u0026#34;./index.css\u0026#34;; import { Authenticator } from \u0026#34;@aws-amplify/ui-react\u0026#34;; ReactDOM.createRoot(document.getElementById(\u0026#34;root\u0026#34;)!).render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Authenticator\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Authenticator\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); This configuration:\nWraps the entire application with the Authenticator component Provides built-in sign-up, sign-in, password reset, and MFA functionality Ensures users must authenticate before accessing the application Configure Main Application Component Update the src/App.tsx file with Amplify integration:\nimport { FormEvent, useState } from \u0026#34;react\u0026#34;; import { Loader, Placeholder } from \u0026#34;@aws-amplify/ui-react\u0026#34;; import \u0026#34;./App.css\u0026#34;; import { Amplify } from \u0026#34;aws-amplify\u0026#34;; import outputs from \u0026#34;../amplify_outputs.json\u0026#34;; import \u0026#34;@aws-amplify/ui-react/styles.css\u0026#34;; Amplify.configure(outputs); function App() { return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;header-container\u0026#34;\u0026gt; \u0026lt;h1 className=\u0026#34;main-header\u0026#34;\u0026gt; This here is \u0026lt;br /\u0026gt; \u0026lt;span className=\u0026#34;highlight\u0026#34;\u0026gt;just a website\u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;description\u0026#34;\u0026gt; You can develop your own website and deploy it to AWS Amplify. \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Key Configuration Elements Amplify Configuration:\nAmplify.configure(outputs): Connects the app to AWS services using generated configuration amplify_outputs.json: Contains service endpoints and configuration details UI Components:\nImports Amplify UI React styles for consistent theming Uses responsive design with proper CSS classes Implements a clean, modern interface The amplify_outputs.json file is automatically generated when you deploy your Amplify backend and contains all necessary configuration for connecting to AWS services.\nAuthentication Features The Authenticator component provides:\nUser registration with email verification Secure sign-in and sign-out functionality Password reset capabilities Multi-factor authentication support Customizable UI themes and styling Result Your application now has complete authentication integration with AWS Amplify, providing secure user access control and a professional user interface.\n"
},
{
	"uri": "http://localhost:1313/12-s3-bucket-for-data-storage/12.2-configure-bucket-settings/",
	"title": "Configure Bucket Settings",
	"tags": [],
	"description": "",
	"content": "Basic Configuration Settings Configure the essential settings for your S3 bucket to ensure proper functionality and security.\nSet Bucket Name and Region Configure the following basic settings:\nBucket name: leftover-storage\nMust be globally unique across all AWS accounts Use lowercase letters, numbers, and hyphens only Region: ap-southeast-1 (Singapore)\nChoose the same region as your Amplify app for optimal performance If \u0026ldquo;leftover-storage\u0026rdquo; is already taken, append a unique identifier like your initials or numbers (e.g., \u0026ldquo;leftover-storage-abc123\u0026rdquo;).\nSecurity Configuration Block Public Access Settings:\nKeep all four settings checked to ensure your data remains private This prevents accidental public exposure of your bucket contents Advanced Features Bucket Versioning:\nEnable versioning for data integrity and recovery capabilities Default Encryption:\nEnable with SSE-S3 (Server-Side Encryption with Amazon S3-Managed Keys) This ensures all objects stored in the bucket are automatically encrypted Result Your bucket configuration is now complete and ready for creation in the next step.\n"
},
{
	"uri": "http://localhost:1313/4-deploy-the-application-via-aws-amplify/4.2-configure-build-settings/",
	"title": "Configure Build Settings",
	"tags": [],
	"description": "",
	"content": "Set Up Build Configuration After connecting your repository, you need to configure the build settings for your Vite React application.\nReview App Settings Amplify will automatically detect your app settings and suggest a build configuration. Review the detected framework (should show Vite or React). Verify the build commands and output directory settings. Edit Build Specification Click Edit next to the build settings or Edit YML file. This opens the amplify.yml configuration editor. Configure amplify.yml File Replace the default configuration with the following optimized build specification:\nversion: 1 backend: phases: preBuild: commands: - npm install build: commands: - nvm use 20 - npm ci --cache .npm --prefer-offline - npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID frontend: phases: build: commands: - npm run build artifacts: baseDirectory: dist files: - \u0026#39;**/*\u0026#39; cache: paths: - node_modules/**/* Ensure proper indentation in the YAML file. Incorrect indentation will cause build failures.\nSave Configuration After editing the amplify.yml file, click Save. Review the build settings to ensure they match your requirements. Configure Environment Variables (Optional) If your application requires environment variables, add them in the Environment variables section. Set any necessary build-time or runtime environment variables. Result Your build configuration is now set up with the proper commands for Vite React application deployment.\n"
},
{
	"uri": "http://localhost:1313/9-setting-up-amazon-bedrock-cross-region/9.2-configure-cross-region-backend/",
	"title": "Configure Cross-Region Backend",
	"tags": [],
	"description": "",
	"content": "Update Amplify Backend Configuration Configure your Amplify backend to use cross-region inference with automatic routing and failover capabilities.\nUpdate Backend Configuration Replace the content of amplify/backend.ts with the following code:\nimport { defineBackend } from \u0026#34;@aws-amplify/backend\u0026#34;; import { data } from \u0026#34;./data/resource\u0026#34;; import { PolicyStatement } from \u0026#34;aws-cdk-lib/aws-iam\u0026#34;; import { auth } from \u0026#34;./auth/resource\u0026#34;; const backend = defineBackend({ auth, data, }); // Use the latest Claude 4.0 model with cross-region inference const crossRegionModelId = \u0026#34;apac.anthropic.claude-sonnet-4-20250514-v1:0\u0026#34;; // Inference profile ID const regionalModelId = \u0026#34;anthropic.claude-sonnet-4-20250514-v1:0\u0026#34;; // Bedrock model ID // Primary region - Cross-region inference will handle routing automatically const bedrockDataSource = backend.data.resources.graphqlApi.addHttpDataSource( \u0026#34;bedrockDS\u0026#34;, \u0026#34;https://bedrock-runtime.ap-southeast-1.amazonaws.com\u0026#34;, { authorizationConfig: { signingRegion: \u0026#34;ap-southeast-1\u0026#34;, signingServiceName: \u0026#34;bedrock\u0026#34;, }, } ); // Grant permissions for cross-region inference profile bedrockDataSource.grantPrincipal.addToPrincipalPolicy( new PolicyStatement({ resources: [ // Cross-region inference profile `arn:aws:bedrock:ap-southeast-1:\u0026lt;UserID\u0026gt;:inference-profile/${crossRegionModelId}`, // Regional model as fallback `arn:aws:bedrock:ap-southeast-1::foundation-model/${regionalModelId}`, // Additional regions that might be used by cross-region inference `arn:aws:bedrock:ap-northeast-1::foundation-model/${regionalModelId}`, `arn:aws:bedrock:ap-southeast-2::foundation-model/${regionalModelId}`, `arn:aws:bedrock:ap-northeast-2::foundation-model/${regionalModelId}`, `arn:aws:bedrock:ap-northeast-3::foundation-model/${regionalModelId}`, // Add wildcard for cross-region inference to handle all regions `arn:aws:bedrock:*::foundation-model/${regionalModelId}`, ], actions: [\u0026#34;bedrock:InvokeModel\u0026#34;, \u0026#34;bedrock:InvokeModelWithResponseStream\u0026#34;], }) ); Configuration Details Model IDs:\ncrossRegionModelId: Inference profile ID for automatic routing regionalModelId: Base model ID used across regions Permission Strategy:\nSpecific Regions: List individual regions for controlled access Wildcard Access: Use * for all regions (simpler but broader permissions) Regional Configuration Options Option 1: Specific Regional Order\n// Define specific region priority `arn:aws:bedrock:ap-southeast-1::foundation-model/${regionalModelId}`, // Primary `arn:aws:bedrock:ap-northeast-1::foundation-model/${regionalModelId}`, // Secondary `arn:aws:bedrock:ap-southeast-2::foundation-model/${regionalModelId}`, // Tertiary Option 2: All Subscribed Regions\n// Allow access to all regions `arn:aws:bedrock:*::foundation-model/${regionalModelId}`, Update Data Schema Replace the content of amplify/data/resource.ts:\nimport { type ClientSchema, a, defineData } from \u0026#34;@aws-amplify/backend\u0026#34;; const schema = a.schema({ BedrockResponse: a.customType({ body: a.string(), error: a.string(), }), askBedrock: a .query() .arguments({ ingredients: a.string().array() }) .returns(a.ref(\u0026#34;BedrockResponse\u0026#34;)) .authorization((allow) =\u0026gt; [allow.authenticated()]) .handler( a.handler.custom({ entry: \u0026#34;./bedrock.js\u0026#34;, dataSource: \u0026#34;bedrockDS\u0026#34; }) ), }); export type Schema = ClientSchema\u0026lt;typeof schema\u0026gt;; export const data = defineData({ schema, authorizationModes: { defaultAuthorizationMode: \u0026#34;apiKey\u0026#34;, apiKeyAuthorizationMode: { expiresInDays: 30, }, }, }); Create Cross-Region Resolver Create amplify/data/bedrock.js with cross-region support:\nexport function request(ctx) { const { ingredients = [] } = ctx.args; // Construct the prompt with the provided ingredients const prompt = `Suggest a recipe idea using these ingredients (Please provide a recipe with the language used in the input ingredients. Provide 2 to 3 different recipes if possible): ${ingredients.join(\u0026#34;, \u0026#34;)}.`; // Use cross-region inference profile for automatic region routing const modelId = \u0026#34;apac.anthropic.claude-sonnet-4-20250514-v1:0\u0026#34;; // Return the request configuration return { resourcePath: `/model/${modelId}/invoke`, method: \u0026#34;POST\u0026#34;, params: { headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, body: JSON.stringify({ anthropic_version: \u0026#34;bedrock-2023-05-31\u0026#34;, max_tokens: 1000, temperature: 0.4, messages: [ { role: \u0026#34;user\u0026#34;, content: [ { type: \u0026#34;text\u0026#34;, text: prompt, }, ], }, ], }), }, }; } export function response(ctx) { // Parse the response body const parsedBody = JSON.parse(ctx.result.body); // Handle potential errors if (parsedBody.error) { return { error: parsedBody.error.message || \u0026#34;Model invocation failed\u0026#34; }; } // Extract the text content from the response const res = { body: parsedBody.content \u0026amp;\u0026amp; parsedBody.content[0].text, }; // Return the response return res; } Replace \u0026lt;UserID\u0026gt; in the inference profile ARN with your actual AWS account ID. You can find this in the Cross-Region Interface section of the Bedrock console.\nResult Your backend is now configured for cross-region inference with automatic routing, failover capabilities, and simplified management compared to the legacy approach.\n"
},
{
	"uri": "http://localhost:1313/13-setup-iam-role-for-lambda/13.2-configure-role-permissions/",
	"title": "Configure Role Permissions",
	"tags": [],
	"description": "",
	"content": "Add Basic Lambda Permissions Configure the essential permissions required for Lambda function execution.\nSelect Permission Policies In the permissions step, search for AWSLambdaBasicExecutionRole. Select the checkbox next to AWSLambdaBasicExecutionRole policy. This policy provides basic execution permissions for Lambda functions. The AWSLambdaBasicExecutionRole policy allows Lambda to write logs to CloudWatch Logs, which is essential for debugging and monitoring.\nName the Role Provide a descriptive name for the role: LeftoverDataCollectionRole. Optionally, add a description explaining the role\u0026rsquo;s purpose. Review the selected policies and trusted entities. Create the Role Click Create role to finalize the role creation. The role will be created and appear in your IAM roles list. Result Your IAM role LeftoverDataCollectionRole is now created with basic Lambda execution permissions. The next step will add S3 access permissions.\n"
},
{
	"uri": "http://localhost:1313/6-setup-iam-identity-center/6.2-configure-user-and-permissions/",
	"title": "Configure User and Permissions",
	"tags": [],
	"description": "",
	"content": "Setup Administrative User via CloudShell Use AWS CloudShell to create an administrative user with proper permissions for Amplify deployment and management.\nAccess AWS CloudShell In the AWS Console, click on the CloudShell icon in the top navigation bar. Wait for the CloudShell environment to initialize. You\u0026rsquo;ll have access to a terminal with AWS CLI pre-configured. Collect User Email Enter the following command to capture your email address:\nread -p \u0026#34;Enter email address: \u0026#34; user_email Type your email address and press Enter. This email will be used for the administrative user account.\nCreate User and Permission Set Execute the following multi-line command to create the user and configure permissions:\nresponse=$(aws sso-admin list-instances) ssoId=$(echo $response | jq \u0026#39;.Instances[0].IdentityStoreId\u0026#39; -r) ssoArn=$(echo $response | jq \u0026#39;.Instances[0].InstanceArn\u0026#39; -r) email_json=$(jq -n --arg email \u0026#34;$user_email\u0026#34; \u0026#39;{\u0026#34;Type\u0026#34;:\u0026#34;Work\u0026#34;,\u0026#34;Value\u0026#34;:$email}\u0026#39;) response=$(aws identitystore create-user --identity-store-id $ssoId --user-name amplify-admin --display-name \u0026#39;Amplify Admin\u0026#39; --name Formatted=string,FamilyName=Admin,GivenName=Amplify --emails \u0026#34;$email_json\u0026#34;) userId=$(echo $response | jq \u0026#39;.UserId\u0026#39; -r) response=$(aws sso-admin create-permission-set --name amplify-policy --instance-arn=$ssoArn --session-duration PT12H) permissionSetArn=$(echo $response | jq \u0026#39;.PermissionSet.PermissionSetArn\u0026#39; -r) aws sso-admin attach-managed-policy-to-permission-set --instance-arn $ssoArn --permission-set-arn $permissionSetArn --managed-policy-arn arn:aws:iam::aws:policy/service-role/AmplifyBackendDeployFullAccess accountId=$(aws sts get-caller-identity | jq \u0026#39;.Account\u0026#39; -r) aws sso-admin create-account-assignment --instance-arn $ssoArn --target-id $accountId --target-type AWS_ACCOUNT --permission-set-arn $permissionSetArn --principal-type USER --principal-id $userId You may see warnings due to the multi-line nature of the command. Continue pasting the entire command block and press Enter to execute.\nWait for Completion The command will execute multiple AWS API calls. Wait for all operations to complete successfully. You should see confirmation messages for each step. Validate Configuration Run the following command to verify the setup and get access information:\nprintf \u0026#34;\\\\n\\\\nStart session url: https://$ssoId.awsapps.com/start\\\\nRegion: $AWS_REGION\\\\nUsername: amplify-admin\\\\n\\\\n\u0026#34; Configuration Details This setup creates:\nUser: amplify-admin with your email address Permission Set: amplify-policy with 12-hour session duration Policy: AmplifyBackendDeployFullAccess for complete Amplify access Account Assignment: Links the user to your AWS account with the permission set Result You now have an administrative user configured with proper permissions for Amplify deployment and management.\n"
},
{
	"uri": "http://localhost:1313/7-setting-up-sandbox/7.2-deploy-sandbox-environment/",
	"title": "Deploy Sandbox Environment",
	"tags": [],
	"description": "",
	"content": "Deploy Amplify Sandbox With AWS credentials configured, you can now deploy the Amplify sandbox environment for local development.\nNavigate to Project Directory Open a terminal in your leftover project directory. Ensure you\u0026rsquo;re in the root folder where package.json and amplify/ directory are located. Deploy Sandbox with Profile Execute the following command to deploy the sandbox:\nnpx ampx sandbox --profile amplify-admin This command will:\nDeploy AWS resources in an isolated sandbox environment Generate the amplify_outputs.json configuration file Set up authentication and data services for local development Monitor Deployment Progress The deployment process will show progress updates. Wait for the message: [Sandbox] Watching for file changes... This indicates the sandbox is successfully deployed and monitoring for changes. Troubleshooting Common Issues Invalid Credentials Error: If you see InvalidCredentialError: Failed to load default AWS credentials:\nVerify your profile configuration with aws configure list --profile amplify-admin Re-run the SSO login: aws sso login --profile amplify-admin SSM Credentials Error: If you encounter SSMCredentialsError: UnrecognizedClientException:\nNavigate to C:\\Users\\YourUserName\\.aws (Windows) or ~/.aws (macOS/Linux) Delete the existing configuration files Reconfigure your profile following the previous step Start Local Development Server Once the sandbox is deployed, start your local development server:\nnpm run dev Create New Account Open your browser and navigate to http://localhost:5173. You should see the Amplify Authenticator component. Click Create Account to start the sign-up process. Fill in the required information (email, password, etc.). Submit the registration form. Verify Email Address Check your email inbox for a verification message from AWS. Open the verification email and click the confirmation link. Return to the application and complete the verification process. Sign in with your newly created and verified credentials. Verify Sandbox Integration After successful authentication, you should see:\nYour application\u0026rsquo;s main interface Proper integration with AWS services Real-time connection to the sandbox environment Ability to interact with authenticated features Result Your Amplify sandbox environment is now fully operational with:\nIsolated AWS resources for development Local development server with hot reloading Complete authentication flow integration Real-time synchronization with cloud services The sandbox environment runs continuously and watches for file changes. Keep the terminal open while developing to maintain the connection to AWS services.\n"
},
{
	"uri": "http://localhost:1313/14-create-lambda-function-for-data-collection/14.2-implement-data-collection-code/",
	"title": "Implement Data Collection Code",
	"tags": [],
	"description": "",
	"content": "Access Function Code Editor After creating the Lambda function, you need to implement the data collection logic.\nNavigate to Code Source Click on the leftover-data-collector function you just created. Scroll down to the Code source section. You will see the default index.mjs file in the code editor. Replace Default Code Select all the existing code in the index.mjs file. Replace it with the following data collection implementation: import { S3Client, PutObjectCommand } from \u0026#34;@aws-sdk/client-s3\u0026#34;; const s3Client = new S3Client({ region: \u0026#34;ap-southeast-1\u0026#34; }); export const handler = async (event) =\u0026gt; { try { const { ingredients, timestamp, userId, sessionId } = JSON.parse(event.body); // Create partition path based on date const date = new Date(timestamp); const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, \u0026#39;0\u0026#39;); const day = String(date.getDate()).padStart(2, \u0026#39;0\u0026#39;); // Create unique filename const filename = `${sessionId}-${Date.now()}.json`; const key = `user-inputs/year=${year}/month=${month}/day=${day}/${filename}`; // Prepare data for storage const dataToStore = { timestamp, userId, sessionId, ingredients: ingredients.split(\u0026#39;,\u0026#39;).map(ing =\u0026gt; ing.trim()), ingredientCount: ingredients.split(\u0026#39;,\u0026#39;).length, rawInput: ingredients, metadata: { userAgent: event.headers[\u0026#39;User-Agent\u0026#39;] || \u0026#39;unknown\u0026#39;, sourceIP: event.requestContext?.identity?.sourceIp || \u0026#39;unknown\u0026#39; } }; // Store in S3 const command = new PutObjectCommand({ Bucket: \u0026#39;leftover-storage\u0026#39;, Key: key, Body: JSON.stringify(dataToStore), ContentType: \u0026#39;application/json\u0026#39; }); await s3Client.send(command); return { statusCode: 200, headers: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;POST, OPTIONS\u0026#39; }, body: JSON.stringify({ message: \u0026#39;Data stored successfully\u0026#39;, key: key }) }; } catch (error) { console.error(\u0026#39;Error storing data:\u0026#39;, error); return { statusCode: 500, headers: { \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39; }, body: JSON.stringify({ error: \u0026#39;Failed to store data\u0026#39; }) }; } }; Deploy the Function After replacing the code, click Deploy to save and deploy your changes. The function will be updated with the new implementation. Code Functionality This Lambda function provides the following capabilities:\nData Processing:\nParses incoming JSON data from API requests Extracts ingredients, timestamp, user ID, and session ID Data Organization:\nCreates date-based partitions (year/month/day) for efficient storage Generates unique filenames using session ID and timestamp S3 Integration:\nStores processed data in the leftover-storage bucket Includes metadata such as user agent and source IP CORS Support:\nEnables cross-origin requests for web application integration Result Your Lambda function is now ready to collect and store user input data with proper organization and error handling.\nThe function automatically organizes data by date, making it easier to query and analyze user inputs over time.\n"
},
{
	"uri": "http://localhost:1313/10-create-the-website-frontend/10.2-implement-main-application/",
	"title": "Implement Main Application",
	"tags": [],
	"description": "",
	"content": "Build Complete React Application Create the main application component with full functionality including API integration, error handling, and user interface.\nUpdate App.tsx Component Replace the content of src/App.tsx with the following comprehensive implementation:\nimport type { FormEvent } from \u0026#34;react\u0026#34;; import { useState, useEffect } from \u0026#34;react\u0026#34;; import { Loader, Placeholder } from \u0026#34;@aws-amplify/ui-react\u0026#34;; import \u0026#34;./App.css\u0026#34;; import { Amplify } from \u0026#34;aws-amplify\u0026#34;; import type { Schema } from \u0026#34;../amplify/data/resource\u0026#34;; import { generateClient } from \u0026#34;aws-amplify/data\u0026#34;; import outputs from \u0026#34;../amplify_outputs.json\u0026#34;; import logoImage from \u0026#34;./assets/pics/logo.png\u0026#34;; import { signOut } from \u0026#34;aws-amplify/auth\u0026#34;; import \u0026#34;@aws-amplify/ui-react/styles.css\u0026#34;; Amplify.configure(outputs); const amplifyClient = generateClient\u0026lt;Schema\u0026gt;({ authMode: \u0026#34;userPool\u0026#34;, }); function App() { const [result, setResult] = useState\u0026lt;string\u0026gt;(\u0026#34;\u0026#34;); const [loading, setLoading] = useState(false); const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;); const [animateIntro, setAnimateIntro] = useState(false); const [error, setError] = useState\u0026lt;string | null\u0026gt;(null); const [usingFallback, setUsingFallback] = useState(false); useEffect(() =\u0026gt; { // Trigger animation after component mounts setAnimateIntro(true); }, []); const callBedrockAPI = async (ingredients: string[], useFallback = false) =\u0026gt; { // Create a promise that will reject after 30 seconds const timeout = new Promise\u0026lt;never\u0026gt;((_, reject) =\u0026gt; { setTimeout(() =\u0026gt; reject(new Error(\u0026#39;Request timed out\u0026#39;)), 30000); }); try { const response = await Promise.race([ useFallback ? amplifyClient.queries.askBedrockFallback({ ingredients }) : amplifyClient.queries.askBedrock({ ingredients }), timeout ]); // If we get here, API request completed before timeout if (!response.data) { throw new Error(\u0026#34;No data returned from the API\u0026#34;); } return response.data.body; } catch (error) { // Re-throw the error to handle it in the calling function throw error; } }; const onSubmit = async (event: FormEvent\u0026lt;HTMLFormElement\u0026gt;) =\u0026gt; { event.preventDefault(); if (!inputValue.trim()) return; setLoading(true); setResult(\u0026#34;\u0026#34;); setError(null); setUsingFallback(false); try { const ingredientsInput = inputValue.trim(); const ingredientsArray = ingredientsInput .split(\u0026#34;,\u0026#34;) .map(ingredient =\u0026gt; ingredient.trim()) .filter(ingredient =\u0026gt; ingredient.length \u0026gt; 0); try { // First try the primary region (ap-southeast-1) const resultText = await callBedrockAPI(ingredientsArray, false); setResult(resultText || \u0026#34;No recipe content returned\u0026#34;); } catch (primaryError) { console.warn(\u0026#34;Primary region failed, trying fallback:\u0026#34;, primaryError); setUsingFallback(true); try { // If primary region fails, try the fallback region (ap-northeast-1) const fallbackResult = await callBedrockAPI(ingredientsArray, true); setResult(fallbackResult || \u0026#34;No recipe content returned\u0026#34;); } catch (fallbackError) { // Both regions failed console.error(\u0026#34;Both regions failed:\u0026#34;, fallbackError); if (fallbackError instanceof Error) { setError(`Service unavailable: ${fallbackError.message}`); } else { setError(\u0026#34;Service is unavailable in all regions. Please try again later.\u0026#34;); } } } } catch (e) { console.error(\u0026#34;Exception:\u0026#34;, e); if (e instanceof Error) { setError(`An error occurred: ${e.message}`); } else { setError(\u0026#34;An unknown error occurred. Please try again.\u0026#34;); } } finally { setLoading(false); } }; const handleInputChange = (e: React.ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { setInputValue(e.target.value); }; const handleLogout = async () =\u0026gt; { try { await signOut(); // The Authenticator will handle the UI change automatically } catch (error) { console.error(\u0026#39;Error signing out: \u0026#39;, error); } }; return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;nav-container\u0026#34;\u0026gt; \u0026lt;button className=\u0026#34;logout-button\u0026#34; onClick={handleLogout}\u0026gt; Log Out \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={`header-container ${animateIntro ? \u0026#39;fade-in\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; \u0026lt;img src={logoImage} alt=\u0026#34;Recipe AI Logo\u0026#34; className=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;h1 className=\u0026#34;main-header\u0026#34;\u0026gt; Do you have some \u0026lt;br /\u0026gt; \u0026lt;span className=\u0026#34;highlight\u0026#34;\u0026gt;Leftover?\u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;description\u0026#34;\u0026gt; Just type in any ingredients you have left in your fridge or pantry, separated by commas. We\u0026#39;ll help you create a delicious recipe with what you already have! \u0026lt;br /\u0026gt; \u0026lt;span className=\u0026#34;multilingual-note\u0026#34;\u0026gt; (Our website supports all languages, please input the ingredients in your language) \u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form onSubmit={onSubmit} className={`form-container ${animateIntro ? \u0026#39;slide-up\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; \u0026lt;div className=\u0026#34;search-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; className=\u0026#34;wide-input\u0026#34; id=\u0026#34;ingredients\u0026#34; name=\u0026#34;ingredients\u0026#34; placeholder=\u0026#34;Chicken, rice, carrots, onion...\u0026#34; value={inputValue} onChange={handleInputChange} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;search-button\u0026#34; disabled={loading || !inputValue.trim()} \u0026gt; {loading ? \u0026#39;Processing...\u0026#39; : \u0026#39;Generate\u0026#39;} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; {(loading || result || error) \u0026amp;\u0026amp; ( \u0026lt;div className={`result-container ${result || loading || error ? \u0026#39;appear\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; {loading ? ( \u0026lt;div className=\u0026#34;loader-container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Creating your personalized recipe...\u0026lt;/p\u0026gt; \u0026lt;Loader size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;Placeholder size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;Placeholder size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;Placeholder size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ) : error ? ( \u0026lt;p className=\u0026#34;result error-message\u0026#34;\u0026gt;{error}\u0026lt;/p\u0026gt; ) : ( \u0026lt;\u0026gt; {usingFallback \u0026amp;\u0026amp; ( \u0026lt;p className=\u0026#34;fallback-notice\u0026#34;\u0026gt;Using fallback region (ap-northeast-1)\u0026lt;/p\u0026gt; )} \u0026lt;p className=\u0026#34;result\u0026#34;\u0026gt;{result}\u0026lt;/p\u0026gt; \u0026lt;/\u0026gt; )} \u0026lt;/div\u0026gt; )} \u0026lt;footer className=\u0026#34;footer\u0026#34;\u0026gt; © {new Date().getFullYear()} Aiden Dinh \u0026amp; Arthur Nguyen \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Key Application Features State Management:\nresult: Stores the generated recipe content loading: Manages loading state during API calls inputValue: Tracks user input for ingredients animateIntro: Controls entrance animations error: Handles error messages usingFallback: Indicates when fallback region is used API Integration:\nPrimary Region: First attempts API call to ap-southeast-1 Fallback Region: Automatically tries ap-northeast-1 if primary fails Timeout Handling: 30-second timeout for all API requests Error Recovery: Comprehensive error handling with user feedback User Interface Components:\nLogo Integration: Custom logo with hover effects Responsive Form: Input field with validation and submit button Loading States: Visual feedback during processing Results Display: Formatted recipe output with error handling Authentication: Logout functionality with Amplify integration Multilingual Support:\nAccepts ingredients in any language Provides recipes in the same language as input Clear instructions for international users This implementation works with both the Legacy (Step 8) and Cross-Region Inference (Step 9) approaches, automatically handling fallback scenarios for maximum reliability.\nResult Your application now has a complete, functional React component with professional error handling, fallback support, and a polished user interface ready for styling.\n"
},
{
	"uri": "http://localhost:1313/2-initialize-and-push-to-github/2.2-initialize-git-and-push/",
	"title": "Initialize Git and Push",
	"tags": [],
	"description": "",
	"content": "Initialize Local Git Repository After creating the GitHub repository, you need to initialize Git in your local project and push the code to the remote repository.\nNavigate to Project Directory Open a terminal or command prompt. Navigate to your leftover project directory: cd leftover Initialize Git Repository Initialize Git version control in your project:\ngit init This command creates a new Git repository in the current directory.\nStage Project Files Add all project files to the Git staging area:\ngit add . This command stages all files in the project directory for the initial commit.\nCreate Initial Commit Create the first commit with your project files:\ngit commit -m \u0026#34;Initial commit: Vite React TypeScript project setup\u0026#34; Connect to Remote Repository Link your local repository to the GitHub repository:\ngit remote add origin https://github.com/your-username/leftover.git Replace your-username with your actual GitHub username.\nSet Main Branch Ensure you\u0026rsquo;re working with the main branch:\ngit branch -M main Push to GitHub Push your local repository to GitHub:\ngit push -u origin main The -u flag sets up tracking between your local main branch and the remote main branch.\nVerify Repository Upload Return to your GitHub repository page in the browser. Refresh the page to see your uploaded project files. Verify that all project files and folders are present. Result Your project is now successfully version-controlled and hosted on GitHub with:\nComplete project history tracked in Git Remote backup of your code on GitHub Ready for AWS service integration and deployment Use git add ., git commit -m \u0026quot;message\u0026quot;, and git push for future updates to save and publish your progress to the repository.\n"
},
{
	"uri": "http://localhost:1313/2-initialize-and-push-to-github/",
	"title": "Initialize Git and Push to GitHub",
	"tags": [],
	"description": "",
	"content": "Content:\nCreate GitHub Repository Initialize Git and Push Version control is essential for project management and deployment. In this section, we\u0026rsquo;ll set up Git version control for the Vite project and push it to a GitHub repository for remote storage and AWS service integration.\nCreate GitHub Repository Access your GitHub account and create a new repository. Configure the repository name and settings. Obtain the repository URL for remote connection. Initialize Git and Push Initialize Git in the local project directory. Stage and commit the project files. Connect to the remote repository and push the code. "
},
{
	"uri": "http://localhost:1313/1-setting-up-vite/1.2-run-development-server/",
	"title": "Run Development Server",
	"tags": [],
	"description": "",
	"content": "Navigate to Project Directory After creating the Vite project, you need to enter the project folder and start the development server.\nEnter Project Folder Navigate to the newly created project directory:\ncd leftover This command changes your current directory to the leftover project folder where all the project files are located.\nInstall Dependencies Install the required project dependencies:\nnpm install This step ensures all packages specified in package.json are properly installed.\nStart Development Server Launch the development server with the following command:\nnpm run dev The development server will start and display:\nLocal server URL (typically http://localhost:5173) Network URL for accessing from other devices Hot module replacement (HMR) status Access the Application Open your web browser and navigate to http://localhost:5173. You should see the default Vite + React welcome screen. The page displays the Vite and React logos with a counter button. Test Hot Module Replacement Open src/App.tsx in your code editor. Make a small change to the text or styling. Save the file and observe the browser automatically update without refresh. Result Your Vite development environment is now running successfully with:\nFast development server with HMR enabled React + TypeScript configuration ready for development Live reloading for efficient development workflow The development server will continue running until you stop it with Ctrl+C. Keep it running while developing your application.\n"
},
{
	"uri": "http://localhost:1313/11-monitoring-with-cloudwatch/11.2-setup-bedrock-metrics-widget/",
	"title": "Setup Bedrock Metrics Widget",
	"tags": [],
	"description": "",
	"content": "Configure a line chart widget to monitor Bedrock token usage patterns for both input and output tokens.\nSelect Bedrock Metrics In the Browse menu, search for Bedrock or scroll to find it in the services list If there are many metrics, use the search bar to quickly locate Bedrock services Navigate to Bedrock \u0026gt; By ModelID to access model-specific metrics Configure Token Metrics Select the relevant metrics for your APAC profile region: OutputTokenCount: Tracks tokens generated by the model InputTokenCount: Tracks tokens sent to the model Choose both metrics to monitor complete token usage patterns Optimize Widget Display Switch to the Options tab for display configuration Show units: Enable to display token count units clearly Set minimum value: Set Min to 0 for easier graph interpretation Data refresh: Choose live data for real-time updates Complete Widget Creation Click Create widget to add it to your dashboard The widget will appear in the top-left position of your dashboard Click the + button to add additional widgets for comprehensive monitoring Result Your Bedrock token usage widget is now active and displaying real-time input and output token metrics. This provides essential visibility into your application\u0026rsquo;s AI model consumption patterns.\nLive data updates ensure you can monitor token usage in real-time, helping you identify usage spikes and optimize your application\u0026rsquo;s performance immediately.\n"
},
{
	"uri": "http://localhost:1313/8-setting-up-amazon-bedrock-legacy/8.2-setup-fallback-region/",
	"title": "Setup Fallback Region",
	"tags": [],
	"description": "",
	"content": "Configure Secondary Region Set up a fallback region to ensure high availability and redundancy for your Bedrock integration.\nSwitch to Fallback Region In the AWS Console, change your region to a secondary region (e.g., ap-northeast-1). Navigate to Amazon Bedrock in the new region. Access the Model Catalog as you did in the primary region. Request Model Access in Fallback Region Follow the same process as the primary region:\nNavigate to Model Catalog. Select Claude 3.5 Sonnet from Anthropic. Click Modify model access or Enable specific model. Select Claude 3.5 Sonnet and submit the request. Wait for Approval Monitor the approval status in the fallback region. Ensure the model becomes available before proceeding. Verify that both regions now have active Claude 3.5 Sonnet access. Document Region Information Keep track of your configured regions:\nPrimary Region: ap-southeast-1 (Singapore) Fallback Region: ap-northeast-1 (Tokyo) Choose regions that are geographically close to your users for optimal performance, while ensuring both regions support the Claude 3.5 Sonnet model.\nVerify Multi-Region Setup Switch between regions in the AWS Console. Confirm Claude 3.5 Sonnet is available in both regions. Note the model ARNs for each region (you\u0026rsquo;ll need these later). Result You now have Claude 3.5 Sonnet access configured in both primary and fallback regions, providing redundancy for your application.\n"
},
{
	"uri": "http://localhost:1313/11-monitoring-with-cloudwatch/11.3-add-invocation-counter-widget/",
	"title": "Add Invocation Counter Widget",
	"tags": [],
	"description": "",
	"content": "Create a number widget to track total Bedrock model invocations with real-time updates and historical trends.\nCreate Invocation Widget Click the + button to add a new widget to your dashboard Configure the widget settings: Data source type: CloudWatch Data type: Metrics Widget type: Number Select Invocation Metrics Browse through the same Bedrock metrics path as the previous widget Navigate to Bedrock \u0026gt; By ModelID Select Invocations as the metric name to track total model calls Configure Display Options Switch to the Options tab for number widget configuration Latest value: Shows the value from the most recent period of your chosen time range Display most recent data points: Enable to see latest updates even when not fully aggregated Display sparkline at bottom: Enable to show the trend graph over time Duplicate Widget for Efficiency To save time for future widgets, click the 3 dots on any existing widget Select Duplicate to create a copy with similar settings This allows quick modification rather than starting from scratch Result Your invocation counter widget now displays the total number of Bedrock model calls with both current count and historical trend visualization. The sparkline provides quick insight into usage patterns over time.\nThe invocation counter helps you understand your application\u0026rsquo;s usage frequency and can be crucial for capacity planning and cost optimization strategies.\n"
},
{
	"uri": "http://localhost:1313/13-setup-iam-role-for-lambda/13.3-add-s3-access-policy/",
	"title": "Add S3 Access Policy",
	"tags": [],
	"description": "",
	"content": "Access the Created Role To add S3 permissions, you need to modify the existing role with additional policies.\nNavigate to Role Details Go back to the Roles section in the IAM console. Click on the LeftoverDataCollectionRole that you just created. This will open the role details page. Add Inline Policy In the role details page, click Add permissions. Select Create inline policy from the dropdown menu. Configure Policy Editor In the Policy Editor, switch from Visual to JSON mode. This allows you to define precise permissions using JSON syntax. Add S3 Permissions Replace the default JSON content with the following policy:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:PutObject\u0026#34;, \u0026#34;s3:PutObjectAcl\u0026#34;, \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::leftover-storage/*\u0026#34; } ] } Finalize Policy Click Next to review the policy. Provide a policy name such as S3AccessPolicy. Click Create policy to attach it to the role. Result Your IAM role now has the necessary permissions to:\nExecute Lambda functions with basic logging capabilities Access S3 bucket operations (PutObject, GetObject, PutObjectAcl) on the leftover-storage bucket The role is now ready to be used by Lambda functions that need to interact with your S3 storage.\n"
},
{
	"uri": "http://localhost:1313/6-setup-iam-identity-center/6.3-complete-user-setup-and-access/",
	"title": "Complete User Setup and Access",
	"tags": [],
	"description": "",
	"content": "Verify Email and Setup Authentication Complete the user setup process by verifying the email address and configuring authentication credentials.\nAccess User Management Return to the IAM Identity Center console. Navigate to Users in the left sidebar. Click on the amplify-admin user you created. Verify Email Address You\u0026rsquo;ll see a notification about email verification. Click on the email verification prompt or button. Check your email inbox for the verification message from AWS. Complete Email Verification Open the verification email from AWS. Click the verification link provided in the email. Follow the instructions to confirm your email address. Reset User Password Return to the IAM Identity Center console. Navigate to Users → amplify-admin. Click Reset password to set up the user\u0026rsquo;s credentials. Configure Password and MFA Click Reset Password and wait for the process to complete. Check your email for the password reset instructions. Follow the email instructions to set a new password. Configure Multi-Factor Authentication (MFA) as prompted. Access AWS Access Portal After completing password and MFA setup, return to IAM Identity Center. Note the AWS Access Portal URL displayed in the console. This URL will be used for future access to AWS resources. Test Access Portal Login Navigate to the AWS Access Portal URL. Sign in using: Username: amplify-admin Password: The password you just created MFA: Your configured multi-factor authentication Verify Access After successful login, you should see:\nAvailable AWS accounts Permission sets assigned to your user Access to AWS services based on your permissions Ability to access the AWS Console with Amplify permissions Result Your IAM Identity Center setup is now complete with:\nVerified administrative user account Proper authentication and MFA configured Access portal ready for secure AWS resource management Full permissions for Amplify deployment and management Save the AWS Access Portal URL and your credentials securely. You\u0026rsquo;ll use this for future access to AWS services and Amplify management.\n"
},
{
	"uri": "http://localhost:1313/8-setting-up-amazon-bedrock-legacy/8.3-configure-backend-integration/",
	"title": "Configure Backend Integration",
	"tags": [],
	"description": "",
	"content": "Update Amplify Backend Configuration Configure your Amplify backend to integrate with Amazon Bedrock using HTTP data sources.\nLocate Backend Configuration Navigate to your project\u0026rsquo;s amplify/ directory. Open the backend.ts file in your code editor. This file defines your backend resources and configurations. Update Backend Configuration Replace the content of amplify/backend.ts with the following code:\nimport { defineBackend } from \u0026#34;@aws-amplify/backend\u0026#34;; import { data } from \u0026#34;./data/resource\u0026#34;; import { PolicyStatement } from \u0026#34;aws-cdk-lib/aws-iam\u0026#34;; import { auth } from \u0026#34;./auth/resource\u0026#34;; const backend = defineBackend({ auth, data, }); // Primary region const bedrockDataSource = backend.data.resources.graphqlApi.addHttpDataSource( \u0026#34;bedrockDS\u0026#34;, \u0026#34;https://bedrock-runtime.ap-southeast-1.amazonaws.com\u0026#34;, { authorizationConfig: { signingRegion: \u0026#34;ap-southeast-1\u0026#34;, signingServiceName: \u0026#34;bedrock\u0026#34;, }, } ); // Fallback region const bedrockFallbackDataSource = backend.data.resources.graphqlApi.addHttpDataSource( \u0026#34;bedrockFallbackDS\u0026#34;, \u0026#34;https://bedrock-runtime.ap-northeast-1.amazonaws.com\u0026#34;, { authorizationConfig: { signingRegion: \u0026#34;ap-northeast-1\u0026#34;, signingServiceName: \u0026#34;bedrock\u0026#34;, }, } ); // Grant permissions for primary region bedrockDataSource.grantPrincipal.addToPrincipalPolicy( new PolicyStatement({ resources: [ \u0026#34;arn:aws:bedrock:ap-southeast-1::foundation-model/anthropic.claude-3-5-sonnet-20240620-v1:0\u0026#34;, ], actions: [\u0026#34;bedrock:InvokeModel\u0026#34;], }) ); // Grant permissions for fallback region bedrockFallbackDataSource.grantPrincipal.addToPrincipalPolicy( new PolicyStatement({ resources: [ \u0026#34;arn:aws:bedrock:ap-northeast-1::foundation-model/anthropic.claude-3-5-sonnet-20240620-v1:0\u0026#34;, ], actions: [\u0026#34;bedrock:InvokeModel\u0026#34;], }) ); Find Model ARN To get the correct Model ARN for your regions:\nGo to Amazon Bedrock → Model Catalog. Filter by Anthropic and select Claude 3.5 Sonnet. Switch to your target region and copy the Model ID. Update Region-Specific ARNs For models like Claude 3.5 Sonnet that don\u0026rsquo;t display the full ARN:\nChange to the correct region in the console. Copy the Model ID from the model details. Replace the model ID in the ARN format: arn:aws:bedrock:REGION::foundation-model/MODEL_ID Configuration Details HTTP Data Sources:\nbedrockDS: Primary region endpoint (ap-southeast-1) bedrockFallbackDS: Fallback region endpoint (ap-northeast-1) IAM Permissions:\nbedrock:InvokeModel: Allows calling the specified foundation models Region-specific ARNs ensure access to models in both regions Ensure the regions in your backend configuration match the regions where you requested model access.\nResult Your Amplify backend is now configured with Bedrock HTTP data sources and proper IAM permissions for both primary and fallback regions.\n"
},
{
	"uri": "http://localhost:1313/12-s3-bucket-for-data-storage/12.3-create-the-bucket/",
	"title": "Create the Bucket",
	"tags": [],
	"description": "",
	"content": "Review and Create After configuring all the necessary settings, it\u0026rsquo;s time to review and create your S3 bucket.\nFinal Review Before creating the bucket:\nReview all your configuration settings to ensure they match the requirements: Bucket name: leftover-storage Region: ap-southeast-1 Public access: Blocked Versioning: Enabled Encryption: SSE-S3 enabled Create the Bucket Scroll down to the bottom of the configuration page. Click Create bucket to finalize the creation process. Successful Creation Once the bucket is created successfully:\nYou will see a confirmation message indicating the bucket was created. Your new S3 bucket will appear in the S3 console bucket list. Result Your S3 bucket leftover-storage is now ready to store your application data securely with:\nVersioning enabled for data integrity Public access blocked for security Default encryption for data protection The bucket is now ready to integrate with your application for secure data storage.\n"
},
{
	"uri": "http://localhost:1313/4-deploy-the-application-via-aws-amplify/4.3-deploy-and-access-application/",
	"title": "Deploy and Access Application",
	"tags": [],
	"description": "",
	"content": "Complete Deployment Setup After configuring the build settings, you\u0026rsquo;re ready to deploy your application to AWS Amplify.\nReview and Deploy Review all configuration settings including repository, branch, and build settings. Click Next to proceed to the final review step. Click Save and Deploy to start the deployment process. Monitor Build Progress Amplify will start the build process automatically. Monitor the build progress in the Amplify console. The build process includes provisioning, building, deploying, and verifying stages. Handle Build Issues (If Any) If the build fails:\nCheck the build logs for error details. Common issues include incorrect build commands or missing dependencies. Edit build settings by going to Hosting → Build Settings. If you need to modify the amplify.yml file after deployment, navigate to Hosting → Build Settings to make changes.\nAccess Deployed Application Once the build completes successfully:\nReturn to the Amplify app overview page. Click Visit deployed URL to access your live application. Verify Application Your Vite React application should load successfully. Test the application functionality to ensure everything works as expected. The application is now live and accessible via the Amplify-generated URL. Set Up Continuous Deployment Your application now has continuous deployment configured:\nAny changes pushed to the main branch will trigger automatic rebuilds The application will be updated automatically with new deployments Build history and logs are available in the Amplify console Result Your Vite React application is now successfully deployed on AWS Amplify with:\nAutomatic builds triggered by GitHub commits Global content delivery via CloudFront HTTPS enabled by default Custom domain support available The deployed URL will remain consistent, making it easy to share and access your application from anywhere.\n"
},
{
	"uri": "http://localhost:1313/3-setting-up-amplify/",
	"title": "Setting Up AWS Amplify",
	"tags": [],
	"description": "",
	"content": "Content:\nInitialize Amplify Project Commit Changes to Git AWS Amplify provides a complete platform for building full-stack applications with cloud services. In this section, we\u0026rsquo;ll initialize Amplify in the project to prepare for AWS resource integration and backend services.\nInitialize Amplify Project Install and configure AWS Amplify in the project directory. Set up the basic Amplify project structure and configuration. Verify the Amplify initialization is successful. Commit Changes to Git Stage the new Amplify configuration files. Create a commit with the Amplify setup changes. Push the updates to the GitHub repository. "
},
{
	"uri": "http://localhost:1313/5-setting-up-frontend-and-backend/5.3-setup-amplify-data-schema/",
	"title": "Setup Amplify Data Schema",
	"tags": [],
	"description": "",
	"content": "Configure Data Layer Set up the Amplify Data resource to define your application\u0026rsquo;s data schema and API configuration.\nCreate Data Resource File Navigate to the amplify/data/ directory in your project. Create a new file named resource.ts. This file will define your data schema and authorization settings. Implement Data Schema Add the following code to amplify/data/resource.ts:\nimport { type ClientSchema, a, defineData } from \u0026#34;@aws-amplify/backend\u0026#34;; const schema = a.schema({ Todo: a .model({ content: a.string(), done: a.boolean().default(false), }) .authorization((allow) =\u0026gt; [allow.owner()]), }); export type Schema = ClientSchema\u0026lt;typeof schema\u0026gt;; export const data = defineData({ schema, authorizationModes: { defaultAuthorizationMode: \u0026#34;apiKey\u0026#34;, apiKeyAuthorizationMode: { expiresInDays: 30, }, }, }); Schema Configuration Details Schema Definition:\nTodo model with content (string) and done (boolean) fields done field defaults to false for new todos Owner-based authorization ensures users can only access their own data Authorization Configuration:\ndefaultAuthorizationMode: \u0026quot;apiKey\u0026quot;: Uses API key for data access expiresInDays: 30: API key remains valid for 30 days Provides secure but convenient access to data operations Data Layer Benefits This configuration provides:\nType Safety: Full TypeScript support for data operations Automatic API Generation: GraphQL API created automatically Real-time Updates: Built-in subscription support for live data Offline Support: Local data caching and sync capabilities Todo Model Features The Todo model provides:\nContent Field: Stores the todo item text Done Field: Tracks completion status with default false value Owner Authorization: Each user can only access their own todos Automatic Timestamps: Created and updated timestamps added automatically The owner authorization ensures data privacy by restricting access to the authenticated user who created each todo item.\nDeploy Data Changes After creating the resource file:\nCommit your changes to Git Push to GitHub to trigger automatic deployment Amplify will provision the necessary AWS resources (AppSync, DynamoDB) Result Your application now has a complete data layer configured with:\nProperly structured data schema foundation API key-based authorization for secure access Type-safe data operations for frontend integration Scalable backend infrastructure ready for future enhancements The data schema will be automatically deployed with your next Amplify build, creating the necessary AWS AppSync API and DynamoDB tables.\n"
},
{
	"uri": "http://localhost:1313/10-create-the-website-frontend/10.3-style-application-interface/",
	"title": "Style Application Interface",
	"tags": [],
	"description": "",
	"content": "Create Modern CSS Styling Implement comprehensive styling with animations, responsive design, and a cohesive visual theme.\nUpdate App.css Replace the content of src/App.css with the following modern styling:\n/* Modern UI Variables */ :root { --dark-yellow: #E6C700; --hue-green: #8DCB85; --dark-green: #116530; --darker-green: #0A4D25; --white: #FFFFFF; --light-background: #fcffe3; --accent-color: #FFD700; --border-radius-sm: 8px; --border-radius-md: 12px; --border-radius-lg: 20px; --box-shadow-sm: 0 4px 6px rgba(0, 0, 0, 0.1); --box-shadow-md: 0 6px 12px rgba(0, 0, 0, 0.15); --box-shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.2); --transition-fast: all 0.2s ease; --transition-normal: all 0.3s ease; --animation-duration: 0.8s; } /* Global Styles */ * { box-sizing: border-box; } body { margin: 0; padding: 0; } /* Animations */ @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } } @keyframes slideUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } } @keyframes appear { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } } .fade-in { animation: fadeIn var(--animation-duration) ease forwards; } .slide-up { animation: slideUp var(--animation-duration) ease forwards; animation-delay: 0.3s; opacity: 0; animation-fill-mode: forwards; } .appear { animation: appear var(--animation-duration) ease forwards; } .app-container { margin: 0 auto; padding: 20px; padding-bottom: 60px; text-align: center; background: var(--light-background); min-height: 100vh; color: var(--dark-green); font-family: \u0026#39;Inter\u0026#39;, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; } /* Logo Styling */ .logo { max-width: 150px; margin-bottom: 1rem; background-color: var(--white); border-radius: 30%; padding: 10px; transition: var(--transition-normal); transform: translateY(0); } .logo:hover { transform: translateY(-5px); box-shadow: var(--box-shadow-lg); } /* Header Styling */ .header-container { padding: 2.5rem; margin: auto; margin-bottom: 2.5rem; text-align: center; align-items: center; max-width: 48rem; background: linear-gradient(135deg, var(--dark-green) 0%, var(--darker-green) 100%); border-radius: var(--border-radius-lg); box-shadow: var(--box-shadow-md); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); width: 100%; } /* Typography */ .main-header { font-size: 2.5rem; font-weight: 800; color: var(--white); letter-spacing: -0.5px; line-height: 1.2; margin-bottom: 1.5rem; } .main-header .highlight { color: var(--accent-color); position: relative; display: inline-block; } .main-header .highlight::after { content: \u0026#39;\u0026#39;; position: absolute; bottom: -3.5px; left: 0; width: 90%; height: 5px; background: var(--accent-color); border-radius: 2px; opacity: 0.6; } .description { font-weight: 400; font-size: 1.125rem; max-width: 65ch; color: var(--white); margin: 1.5rem auto; line-height: 1.6; opacity: 0.9; } .multilingual-note { font-size: 0.85rem; opacity: 0.8; font-style: italic; display: inline-block; margin-top: 0.5rem; } /* Form Styling */ .form-container { margin-bottom: 2rem; background: linear-gradient(145deg, var(--dark-green) 0%, var(--darker-green) 100%); border-radius: var(--border-radius-lg); padding: 2rem; max-width: 800px; margin: 0 auto 2rem; box-shadow: var(--box-shadow-md); border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(5px); width: 100%; } .search-container { display: flex; flex-direction: column; gap: 1rem; align-items: center; width: 100%; } .wide-input { width: 100%; padding: 1rem 1.25rem; font-size: 1rem; border: 2px solid rgba(141, 203, 133, 0.5); border-radius: var(--border-radius-md); background-color: rgba(255, 255, 255, 0.9); color: var(--dark-green); transition: var(--transition-fast); box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05); } .wide-input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 3px rgba(230, 199, 0, 0.3), inset 0 2px 4px rgba(0, 0, 0, 0.05); } .wide-input::placeholder { color: rgba(17, 101, 48, 0.5); } .search-button { width: 100%; max-width: 300px; padding: 0.9rem 1.5rem; font-size: 1rem; background: linear-gradient(to right, var(--dark-yellow) 0%, #ffdc60 100%); color: var(--white); border: none; border-radius: var(--border-radius-md); cursor: pointer; font-weight: 600; transition: var(--transition-normal); letter-spacing: 0.5px; text-transform: uppercase; box-shadow: var(--box-shadow-sm); } .search-button:hover:not(:disabled) { background: linear-gradient(to right, var(--hue-green) 0%, #A0E897 100%); transform: translateY(-3px); box-shadow: var(--box-shadow-md); } .search-button:active:not(:disabled) { transform: translateY(-1px); } .search-button:disabled { opacity: 0.6; cursor: not-allowed; background: #cccccc; color: #666666; } /* Results Area */ .result-container { transition: var(--transition-normal); overflow: hidden; max-width: 800px; margin: 2rem auto; background: linear-gradient(145deg, var(--dark-green) 0%, var(--darker-green) 100%); border-radius: var(--border-radius-lg); padding: 0.5rem; box-shadow: var(--box-shadow-md); border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(5px); width: 100%; } .loader-container { display: flex; flex-direction: column; align-items: center; gap: 1rem; background: transparent; border-radius: var(--border-radius-md); padding: 2rem; } .loader-container p { font-size: 1.1rem; color: var(--white); margin-bottom: 1rem; } .result { background: linear-gradient(to bottom, #f4f7d9 0%, #f5fcbf 100%); border: none; border-radius: var(--border-radius-md); padding: 2rem; white-space: pre-wrap; word-wrap: break-word; color: var(--dark-green); font-weight: 400; text-align: left; box-shadow: var(--box-shadow-md); margin: 1rem; width: calc(100% - 2rem); line-height: 1.6; } .error-message { background: linear-gradient(to bottom, #fff0f0 0%, #ffe0e0 100%); color: #d32f2f; border-left: 4px solid #d32f2f; } /* Logout Button */ .nav-container { position: absolute; top: 20px; right: 20px; z-index: 10; } .logout-button { background: var(--dark-green); color: var(--white); border: none; border-radius: var(--border-radius-md); padding: 8px 16px; font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: var(--transition-fast); box-shadow: var(--box-shadow-sm); } .logout-button:hover { background: var(--darker-green); transform: translateY(-2px); box-shadow: var(--box-shadow-md); } /* Footer Styling */ .footer { width: 100%; background-color: #000; color: var(--white); padding: 12px 0; text-align: center; font-size: 0.85rem; position: fixed; bottom: 0; left: 0; right: 0; } /* Responsive Adjustments */ @media (min-width: 768px) { .main-header { font-size: 3.75rem; } .search-container { flex-direction: row; } .search-button { width: auto; min-width: 150px; } .wide-input { flex: 1; } } @media (max-width: 480px) { .header-container, .form-container, .result-container { padding: 1.5rem; } .main-header { font-size: 2rem; } .logo { max-width: 100px; } } Update index.css Replace the content of src/index.css with base styling:\n:root { font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif; line-height: 1.5; font-weight: 400; color: rgba(255, 255, 255, 0.87); background-color: #fcffe3; font-synthesis: none; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; max-width: 1280px; margin: 0 auto; padding: 2rem; } body { margin: 0; padding: 0; min-width: 320px; min-height: 100vh; background-color: #fcffe3; } .card { padding: 2em; } .read-the-docs { color: #8DCB85; } .box:nth-child(3n + 1) { grid-column: 1; } .box:nth-child(3n + 2) { grid-column: 2; } .box:nth-child(3n + 3) { grid-column: 3; } Design System Features Color Palette:\nPrimary Green: Dark and darker green shades for headers and containers Accent Yellow: Gold accents for highlights and interactive elements Background: Light cream color for a warm, inviting feel Text: High contrast colors for excellent readability Typography:\nFont Family: Inter for modern, clean appearance Hierarchy: Clear size and weight distinctions Spacing: Consistent line heights and margins Interactive Elements:\nHover Effects: Subtle animations and color transitions Focus States: Clear visual feedback for accessibility Loading States: Professional loading indicators with placeholders Responsive Design:\nMobile First: Optimized for small screens Breakpoints: Tablet and desktop optimizations Flexible Layouts: Adapts to different screen sizes Visual Result The final application should display:\nTest Your Application Now you can test the recipe generation functionality! Type in any ingredients you currently have available (e.g., \u0026ldquo;chicken, rice, tomatoes, onions\u0026rdquo;) and the application will generate at least 2 complete recipes with pictures to help you create delicious meals with what\u0026rsquo;s in your kitchen.\nResult Your application now has a complete, modern interface with:\nProfessional Design: Clean, modern aesthetic with consistent branding Smooth Animations: Entrance animations and interactive feedback Responsive Layout: Works perfectly on all device sizes Accessibility: High contrast colors and clear focus states User Experience: Intuitive interface with clear visual hierarchy The styling includes a footer with copyright information that can be customized or removed based on your preferences.\n"
},
{
	"uri": "http://localhost:1313/9-setting-up-amazon-bedrock-cross-region/9.3-update-frontend-integration/",
	"title": "Update Frontend Integration",
	"tags": [],
	"description": "",
	"content": "Implement Frontend Application Update your React application to integrate with the cross-region Bedrock implementation.\nUpdate App Component Replace the content of src/App.tsx with the following enhanced implementation:\nimport type { FormEvent } from \u0026#34;react\u0026#34;; import { useState, useEffect } from \u0026#34;react\u0026#34;; import { Loader, Placeholder } from \u0026#34;@aws-amplify/ui-react\u0026#34;; import \u0026#34;./App.css\u0026#34;; import { Amplify } from \u0026#34;aws-amplify\u0026#34;; import type { Schema } from \u0026#34;../amplify/data/resource\u0026#34;; import { generateClient } from \u0026#34;aws-amplify/data\u0026#34;; import outputs from \u0026#34;../amplify_outputs.json\u0026#34;; import logoImage from \u0026#34;./assets/pics/logo.png\u0026#34;; import { signOut } from \u0026#34;aws-amplify/auth\u0026#34;; import \u0026#34;@aws-amplify/ui-react/styles.css\u0026#34;; Amplify.configure(outputs); const amplifyClient = generateClient\u0026lt;Schema\u0026gt;({ authMode: \u0026#34;userPool\u0026#34;, }); function App() { const [result, setResult] = useState\u0026lt;string\u0026gt;(\u0026#34;\u0026#34;); const [loading, setLoading] = useState(false); const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;); const [animateIntro, setAnimateIntro] = useState(false); const [error, setError] = useState\u0026lt;string | null\u0026gt;(null); useEffect(() =\u0026gt; { // Trigger animation after component mounts setAnimateIntro(true); }, []); const callBedrockAPI = async (ingredients: string[]) =\u0026gt; { // Create a promise that will reject after 30 seconds const timeout = new Promise\u0026lt;never\u0026gt;((_, reject) =\u0026gt; { setTimeout(() =\u0026gt; reject(new Error(\u0026#39;Request timed out\u0026#39;)), 30000); }); try { console.log(\u0026#39;Calling Bedrock API with cross-region inference, ingredients:\u0026#39;, ingredients); const response = await Promise.race([ amplifyClient.queries.askBedrock({ ingredients }), timeout ]); console.log(\u0026#39;Received response:\u0026#39;, response); // If we get here, API request completed before timeout if (!response.data) { throw new Error(\u0026#34;No data returned from the API\u0026#34;); } // Check if there\u0026#39;s an error in the response if (response.data.error) { console.error(\u0026#39;Bedrock API returned error:\u0026#39;, response.data.error); console.error(\u0026#39;Full response:\u0026#39;, response); throw new Error(response.data.error); } // Check if body is empty or null if (!response.data.body) { throw new Error(\u0026#34;Empty response body from the API\u0026#34;); } return response.data.body; } catch (error) { // Re-throw the error to handle it in the calling function throw error; } }; const onSubmit = async (event: FormEvent\u0026lt;HTMLFormElement\u0026gt;) =\u0026gt; { event.preventDefault(); if (!inputValue.trim()) return; setLoading(true); setResult(\u0026#34;\u0026#34;); setError(null); try { const ingredientsInput = inputValue.trim(); const ingredientsArray = ingredientsInput .split(\u0026#34;,\u0026#34;) .map(ingredient =\u0026gt; ingredient.trim()) .filter(ingredient =\u0026gt; ingredient.length \u0026gt; 0); // Use cross-region inference - AWS Bedrock will handle routing automatically const resultText = await callBedrockAPI(ingredientsArray); setResult(resultText || \u0026#34;No recipe content returned\u0026#34;); } catch (e) { console.error(\u0026#34;Cross-region inference failed:\u0026#34;, e); if (e instanceof Error) { setError(`Service error: ${e.message}`); } else { setError(\u0026#34;Service is currently unavailable. Please try again later.\u0026#34;); } } finally { setLoading(false); } }; const handleInputChange = (e: React.ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { setInputValue(e.target.value); }; const handleLogout = async () =\u0026gt; { try { await signOut(); // The Authenticator will handle the UI change automatically } catch (error) { console.error(\u0026#39;Error signing out: \u0026#39;, error); } }; return ( \u0026lt;div className=\u0026#34;app-container\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;nav-container\u0026#34;\u0026gt; \u0026lt;button className=\u0026#34;logout-button\u0026#34; onClick={handleLogout}\u0026gt; Log Out \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className={`header-container ${animateIntro ? \u0026#39;fade-in\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; \u0026lt;img src={logoImage} alt=\u0026#34;Recipe AI Logo\u0026#34; className=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;h1 className=\u0026#34;main-header\u0026#34;\u0026gt; Do you have some \u0026lt;br /\u0026gt; \u0026lt;span className=\u0026#34;highlight\u0026#34;\u0026gt;Leftover?\u0026lt;/span\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;p className=\u0026#34;description\u0026#34;\u0026gt; Just type in any ingredients you have left in your fridge or pantry, separated by commas. We\u0026#39;ll help you create a delicious recipe with what you already have! \u0026lt;br /\u0026gt; \u0026lt;span className=\u0026#34;multilingual-note\u0026#34;\u0026gt; (Our website supports all languages, please input the ingredients in your language) \u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form onSubmit={onSubmit} className={`form-container ${animateIntro ? \u0026#39;slide-up\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; \u0026lt;div className=\u0026#34;search-container\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; className=\u0026#34;wide-input\u0026#34; id=\u0026#34;ingredients\u0026#34; name=\u0026#34;ingredients\u0026#34; placeholder=\u0026#34;Chicken, rice, carrots, onion...\u0026#34; value={inputValue} onChange={handleInputChange} /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; className=\u0026#34;search-button\u0026#34; disabled={loading || !inputValue.trim()} \u0026gt; {loading ? \u0026#39;Processing...\u0026#39; : \u0026#39;Generate\u0026#39;} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; {(loading || result || error) \u0026amp;\u0026amp; ( \u0026lt;div className={`result-container ${result || loading || error ? \u0026#39;appear\u0026#39; : \u0026#39;\u0026#39;}`}\u0026gt; {loading ? ( \u0026lt;div className=\u0026#34;loader-container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Creating your personalized recipe...\u0026lt;/p\u0026gt; \u0026lt;Loader size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;Placeholder size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;Placeholder size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;Placeholder size=\u0026#34;large\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ) : error ? ( \u0026lt;p className=\u0026#34;result error-message\u0026#34;\u0026gt;{error}\u0026lt;/p\u0026gt; ) : ( \u0026lt;p className=\u0026#34;result\u0026#34;\u0026gt;{result}\u0026lt;/p\u0026gt; )} \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } export default App; Key Implementation Features Cross-Region Benefits:\nAutomatic Routing: Bedrock handles region selection automatically Improved Reliability: Built-in failover across multiple regions Simplified Configuration: Single inference profile instead of multiple endpoints Better Performance: Automatic load balancing and latency optimization Error Handling:\n30-second timeout for API requests Comprehensive error logging and user feedback Graceful fallback for service unavailability User Experience:\nMultilingual support for ingredient input Real-time loading indicators with placeholders Responsive design with animations Clear error messages and status updates Cost Estimation To calculate the cost of using Claude 4 Sonnet with cross-region inference:\nVisit the AWS Bedrock Pricing page Select your region (Asia Pacific) and model (Claude 4 Sonnet by Anthropic) Use the formula: (0.003 × input tokens / 1000) + (0.015 × output tokens / 1000) Deploy and Test Save all files and commit changes to Git:\ngit add . git commit -m \u0026#34;Implement cross-region Bedrock inference\u0026#34; git push Test the application with various ingredient combinations\nMonitor the console for cross-region routing behavior\nVerify automatic failover functionality\nResult Your application now uses Amazon Bedrock\u0026rsquo;s Cross-Region Inference for:\nEnhanced Reliability: Automatic failover across multiple regions Simplified Management: Single configuration for multi-region access Improved Performance: Optimized routing and load balancing Better User Experience: Consistent response times and availability Cross-Region Inference provides the most robust and production-ready implementation for Bedrock integration, making it the recommended approach for this project.\n"
},
{
	"uri": "http://localhost:1313/11-monitoring-with-cloudwatch/11.4-create-cost-calculation-widget/",
	"title": "Create Cost Calculation Widget",
	"tags": [],
	"description": "",
	"content": "Implement mathematical functions to calculate real-time costs based on Bedrock token usage and pricing models.\nDuplicate and Edit Widget Click the 3 dots on an existing widget and select Duplicate On the new duplicated widget, click the 3 dots again and choose Edit This provides a foundation for adding cost calculation functions Add Mathematical Functions In the top-right of the graphed metrics section, click Add math Choose All functions from the dropdown menu Select any function initially (you\u0026rsquo;ll modify it to fit your specific cost calculation needs) Configure Cost Calculation Formulas Click the pen icon in the details tab of the newly created metrics to modify equations Implement the cost calculation based on Bedrock pricing: Input tokens: $0.003 per 1000 tokens Output tokens: $0.015 per 1000 tokens Implement Cost Formulas Configure the mathematical expressions for cost tracking:\nTotal Token Cost Formula:\n(m2*0.003/1000)+(m1*0.015/1000) Where:\nm2 = Input token count m1 = Output token count Average Cost Per Invocation:\ne1/m3 Where:\ne1 = Total cost calculation result m3 = Total invocations Important: Uncheck unnecessary metrics from the graphs to prevent confusion and focus on cost data.\nOptimize Display Settings Switch to the Options tab for final configuration Show as many digits as can fit: Enable before rounding to see precise small costs Latest value: Choose to show from the most recent period of your time range Display sparkline at bottom: Enable for trend visualization Complete Dashboard Setup Apply the same mathematical approach to create additional cost-related metrics as needed. Your final dashboard should display comprehensive monitoring including:\nToken usage trends (input/output) Total invocation counts Real-time cost calculations Cost per invocation metrics Result Your CloudWatch dashboard now provides complete visibility into your Bedrock application\u0026rsquo;s performance and costs. The mathematical functions automatically calculate expenses based on actual token usage, enabling proactive cost management and optimization.\nMonitor your cost calculations regularly to ensure they align with current AWS Bedrock pricing. Pricing may change, requiring formula updates to maintain accuracy.\nSet up CloudWatch alarms based on these cost metrics to receive notifications when usage exceeds your defined thresholds, helping prevent unexpected charges.\n"
},
{
	"uri": "http://localhost:1313/4-deploy-the-application-via-aws-amplify/",
	"title": "Deploy Application via AWS Amplify",
	"tags": [],
	"description": "",
	"content": "Content:\nConnect GitHub to Amplify Configure Build Settings Deploy and Access Application AWS Amplify provides seamless hosting and CI/CD capabilities for modern web applications. In this section, we\u0026rsquo;ll deploy the Vite React application using Amplify\u0026rsquo;s hosting feature with GitHub integration for automated deployments.\nConnect GitHub to Amplify Access the AWS Amplify console and create a new app. Connect your GitHub repository as the source provider. Configure repository and branch settings for deployment. Configure Build Settings Set up the build configuration and environment settings. Edit the amplify.yml file with proper build commands. Configure frontend and backend build phases. Deploy and Access Application Complete the deployment configuration and start the build process. Monitor the deployment progress and resolve any issues. Access the deployed application via the generated URL. "
},
{
	"uri": "http://localhost:1313/8-setting-up-amazon-bedrock-legacy/8.4-update-data-schema/",
	"title": "Update Data Schema",
	"tags": [],
	"description": "",
	"content": "Create Custom Resolver Function Create a custom resolver to handle Bedrock API requests and responses.\nCreate Bedrock Resolver Navigate to the amplify/data/ directory. Create a new file named bedrock.js. Add the following resolver code: export function request(ctx) { const { ingredients = [], useFallback } = ctx.args; // Construct the prompt with the provided ingredients const prompt = `Suggest a recipe idea using these ingredients (Please provide a recipe with the language used in the input ingredients. Provide 2 to 3 different recipes if possible): ${ingredients.join(\u0026#34;, \u0026#34;)}.`; // Determine which endpoint to use based on the useFallback parameter // If useFallback is undefined or false, use the primary endpoint const endpoint = useFallback === true ? \u0026#34;bedrockFallbackDS\u0026#34; // Use fallback : \u0026#34;bedrockDS\u0026#34;; // Use primary // Return the request configuration return { resourcePath: `/model/anthropic.claude-3-5-sonnet-20240620-v1:0/invoke`, method: \u0026#34;POST\u0026#34;, params: { headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, }, body: JSON.stringify({ anthropic_version: \u0026#34;bedrock-2023-05-31\u0026#34;, max_tokens: 1000, temperature: 0.4, messages: [ { role: \u0026#34;user\u0026#34;, content: [ { type: \u0026#34;text\u0026#34;, text: `\\n\\nHuman: ${prompt}\\n\\nAssistant:`, }, ], }, ], }), }, }; } export function response(ctx) { // Parse the response body const parsedBody = JSON.parse(ctx.result.body); // Extract the text content from the response const res = { body: parsedBody.content[0].text, }; // Return the response return res; } Resolver Configuration Parameters Key Parameters:\nprompt: Custom prompt construction for recipe suggestions resourcePath: Model endpoint path with Model ID max_tokens: Maximum response length (1000 characters) temperature: Response randomness (0.4 for balanced creativity) type: Data type being sent (text in this case) Update Data Schema Replace the content of amplify/data/resource.ts with:\nimport { type ClientSchema, a, defineData } from \u0026#34;@aws-amplify/backend\u0026#34;; const schema = a.schema({ BedrockResponse: a.customType({ body: a.string(), error: a.string(), }), askBedrock: a .query() .arguments({ ingredients: a.string().array(), useFallback: a.boolean() }) .returns(a.ref(\u0026#34;BedrockResponse\u0026#34;)) .authorization((allow) =\u0026gt; [allow.authenticated()]) .handler( a.handler.custom({ entry: \u0026#34;./bedrock.js\u0026#34;, dataSource: \u0026#34;bedrockDS\u0026#34; }) ), askBedrockFallback: a .query() .arguments({ ingredients: a.string().array() }) .returns(a.ref(\u0026#34;BedrockResponse\u0026#34;)) .authorization((allow) =\u0026gt; [allow.authenticated()]) .handler( a.handler.custom({ entry: \u0026#34;./bedrock.js\u0026#34;, dataSource: \u0026#34;bedrockFallbackDS\u0026#34; }) ), }); export type Schema = ClientSchema\u0026lt;typeof schema\u0026gt;; export const data = defineData({ schema, authorizationModes: { defaultAuthorizationMode: \u0026#34;apiKey\u0026#34;, apiKeyAuthorizationMode: { expiresInDays: 30, }, }, }); Schema Components Custom Types:\nBedrockResponse: Defines the structure of Bedrock API responses Queries:\naskBedrock: Primary query with fallback option askBedrockFallback: Dedicated fallback query Authorization:\nallow.authenticated(): Requires user authentication API key mode for development convenience Deploy Changes Save all files in the amplify/ directory. Commit your changes to Git: git add . git commit -m \u0026#34;Add Bedrock integration with fallback support\u0026#34; git push The changes will be automatically deployed via Amplify. Result Your application now has complete Bedrock integration with:\nCustom resolver for recipe generation Primary and fallback region support Authenticated access to Claude 3.5 Sonnet Flexible prompt configuration The schema update will create GraphQL queries that your frontend can use to interact with the Bedrock models for recipe generation.\n"
},
{
	"uri": "http://localhost:1313/5-setting-up-frontend-and-backend/",
	"title": "Setting Up Frontend and Backend",
	"tags": [],
	"description": "",
	"content": "Content:\nInstall Dependencies and Setup Frontend Configure Authentication and Backend Setup Amplify Data Schema With AWS Amplify initialized and deployed, we now need to integrate frontend components and backend services. In this section, we\u0026rsquo;ll install necessary dependencies, configure authentication, and set up the application\u0026rsquo;s user interface and data layer.\nInstall Dependencies and Setup Frontend Install AWS Amplify libraries and UI components. Configure CSS styling for the application interface. Set up the basic frontend structure and layout. Configure Authentication and Backend Implement Amplify Authenticator for user authentication. Configure the main application component with Amplify integration. Set up authentication flow and user interface components. Setup Amplify Data Schema Create and configure the Amplify data resource. Define the data schema and authorization modes. Set up API key authentication for data access. "
},
{
	"uri": "http://localhost:1313/6-setup-iam-identity-center/",
	"title": "Setup IAM Identity Center",
	"tags": [],
	"description": "",
	"content": "Content:\nEnable IAM Identity Center Configure User and Permissions Complete User Setup and Access AWS IAM Identity Center provides centralized access management for AWS accounts and applications. In this section, we\u0026rsquo;ll set up IAM Identity Center to manage user access and permissions for your Amplify application deployment and management.\nEnable IAM Identity Center Access the IAM Identity Center service in the AWS Console. Enable IAM Identity Center with AWS Organizations integration. Complete the basic setup and configuration. Configure User and Permissions Use AWS CloudShell to create an administrative user. Set up permission sets with Amplify deployment access. Assign the user to the AWS account with appropriate permissions. Complete User Setup and Access Verify email address and set up user authentication. Configure password and multi-factor authentication. Access the AWS Access Portal and verify functionality. "
},
{
	"uri": "http://localhost:1313/7-setting-up-sandbox/",
	"title": "Setting Up AWS Sandbox",
	"tags": [],
	"description": "",
	"content": "Content:\nConfigure AWS Credentials Deploy Sandbox Environment AWS Amplify Sandbox provides an isolated development environment that allows developers to rapidly test and integrate AWS services. In this section, we\u0026rsquo;ll configure AWS credentials and deploy a sandbox environment for local development and testing.\nConfigure AWS Credentials Set up AWS CLI configuration with SSO authentication. Configure the amplify-admin profile for sandbox access. Authorize and verify the SSO connection. Deploy Sandbox Environment Deploy the Amplify sandbox with the configured profile. Generate the amplify_outputs.json configuration file. Test the local development environment with authentication. "
},
{
	"uri": "http://localhost:1313/8-setting-up-amazon-bedrock-legacy/",
	"title": "Setting Up Amazon Bedrock (Legacy)",
	"tags": [],
	"description": "",
	"content": "Content:\nRequest Model Access Setup Fallback Region Configure Backend Integration Update Data Schema Amazon Bedrock provides access to foundation models from leading AI companies through a fully managed service. In this section, we\u0026rsquo;ll set up Bedrock integration using the legacy approach with direct HTTP data sources and custom resolvers.\nRequest Model Access Access the Amazon Bedrock console and navigate to the Model Catalog. Request access to Claude 3.5 Sonnet model in your primary region. Configure model permissions and wait for approval. Setup Fallback Region Configure model access in a secondary region for redundancy. Set up the same Claude 3.5 Sonnet model in the fallback region. Verify both regions have active model access. Configure Backend Integration Update the Amplify backend configuration with Bedrock data sources. Configure HTTP data sources for both primary and fallback regions. Set up IAM permissions for model invocation. Update Data Schema Create custom resolver functions for Bedrock integration. Update the data schema with Bedrock query definitions. Configure authentication and response handling. "
},
{
	"uri": "http://localhost:1313/9-setting-up-amazon-bedrock-cross-region/",
	"title": "Setting Up Amazon Bedrock (Cross-Region Inference)",
	"tags": [],
	"description": "",
	"content": "Content:\nRequest Cross-Region Model Access Configure Cross-Region Backend Update Frontend Integration Amazon Bedrock Cross-Region Inference provides automatic routing and failover across multiple regions for improved availability and performance. This is the main implementation approach for this project, offering simplified configuration and better reliability compared to the legacy method.\nImportant: Choose either Step 8 (Legacy) OR Step 9 (Cross-Region Inference). Do not mix implementations between these two approaches as they use different configuration patterns and may cause conflicts.\nRequest Cross-Region Model Access Access Amazon Bedrock and request Claude 4 Sonnet model access. Enable cross-region inference capabilities for the model. Configure inference profiles for automatic region routing. Configure Cross-Region Backend Update Amplify backend with cross-region inference configuration. Set up inference profile permissions and regional model access. Configure automatic routing and failover mechanisms. Update Frontend Integration Implement the frontend application with cross-region support. Update resolver functions for cross-region model invocation. Configure error handling and timeout management. Cross-Region Inference automatically handles region selection, load balancing, and failover, making it the recommended approach for production applications requiring high availability.\n"
},
{
	"uri": "http://localhost:1313/10-create-the-website-frontend/",
	"title": "Create The Website Frontend",
	"tags": [],
	"description": "",
	"content": "Content:\nSetup Assets and Logo Implement Main Application Style Application Interface With the backend services configured, we now need to create a polished frontend interface for the recipe generation application. In this section, we\u0026rsquo;ll build a complete user interface with modern styling, animations, and responsive design.\nSetup Assets and Logo Create the necessary folder structure for assets and images. Add a custom logo for branding and visual appeal. Organize project files for maintainable development. Implement Main Application Build the main React application component with full functionality. Integrate Bedrock API calls with error handling and fallback support. Implement user authentication, form handling, and state management. Style Application Interface Create modern CSS styling with animations and responsive design. Implement a cohesive color scheme and typography system. Add interactive elements and visual feedback for better user experience. "
},
{
	"uri": "http://localhost:1313/11-monitoring-with-cloudwatch/",
	"title": "Monitoring with CloudWatch",
	"tags": [],
	"description": "",
	"content": "Content:\nCreate CloudWatch Dashboard Setup Bedrock Metrics Widget Add Invocation Counter Widget Create Cost Calculation Widget Amazon CloudWatch provides comprehensive monitoring capabilities for your Bedrock-powered application. By creating custom dashboards, you can track token usage, invocation counts, and calculate real-time costs to optimize your application\u0026rsquo;s performance and budget.\nCloudWatch dashboards help you visualize your application\u0026rsquo;s usage patterns and costs in real-time, enabling proactive monitoring and optimization of your AI-powered recipe generator.\nCreate CloudWatch Dashboard Navigate to CloudWatch console and access the Dashboards section. Create a new dashboard with appropriate naming conventions. Configure the initial dashboard settings and data sources. Setup Bedrock Metrics Widget Add a line chart widget to track input and output token counts. Configure Bedrock metrics filtering by ModelID for your specific region. Optimize widget display options for better visualization. Add Invocation Counter Widget Create a number widget to display total invocation counts. Configure real-time data updates and sparkline visualization. Set up proper time range and aggregation settings. Create Cost Calculation Widget Duplicate existing widgets and add mathematical functions. Implement cost calculation formulas for input and output tokens. Configure cost per invocation metrics and display options. Regular monitoring of your Bedrock usage helps identify optimization opportunities and prevents unexpected costs while ensuring optimal application performance.\n"
},
{
	"uri": "http://localhost:1313/12-s3-bucket-for-data-storage/",
	"title": "Creating S3 Bucket for Data Storage",
	"tags": [],
	"description": "",
	"content": "Content:\nNavigate to S3 Console Configure Bucket Settings Create the Bucket Amazon S3 (Simple Storage Service) provides secure, durable, and scalable object storage. In this section, we\u0026rsquo;ll create an S3 bucket to store application data with proper security and versioning configurations.\nNavigate to S3 Console Access the AWS Management Console and search for the S3 service. Click Create bucket to begin the bucket creation process. This opens the configuration page where you\u0026rsquo;ll specify all bucket settings. Configure Bucket Settings Set the bucket name to leftover-storage (must be globally unique). Select region ap-southeast-1 to match your Amplify app location. Keep all Block Public Access settings checked for security. Enable Bucket Versioning for data integrity and recovery. Enable Default Encryption with SSE-S3 for automatic data protection. Create the Bucket Review all configuration settings to ensure they match requirements. Click Create bucket to finalize the creation process. Verify the bucket appears successfully in your S3 console. "
},
{
	"uri": "http://localhost:1313/13-setup-iam-role-for-lambda/",
	"title": "Setting Up IAM Role for Lambda",
	"tags": [],
	"description": "",
	"content": "Content:\nCreate IAM Role Configure Role Permissions Add S3 Access Policy AWS Identity and Access Management (IAM) roles provide secure access to AWS services. In this section, we\u0026rsquo;ll create an IAM role that allows Lambda functions to access S3 storage and execute basic operations.\nCreate IAM Role Navigate to the IAM console and access the Roles section. Create a new role with AWS Service as trusted entity. Select Lambda as the use case for the role. Configure Role Permissions Attach the AWSLambdaBasicExecutionRole policy for basic Lambda execution. Name the role LeftoverDataCollectionRole for easy identification. Complete the role creation process. Add S3 Access Policy Access the newly created role and add additional permissions. Create an inline policy for S3 access permissions. Configure JSON policy to allow S3 operations on the leftover-storage bucket. "
},
{
	"uri": "http://localhost:1313/14-create-lambda-function-for-data-collection/",
	"title": "Creating Lambda Function for Data Collection",
	"tags": [],
	"description": "",
	"content": "Content:\nCreate Lambda Function Implement Data Collection Code AWS Lambda allows you to run code without provisioning servers. In this section, we\u0026rsquo;ll create a Lambda function that collects user input data and stores it in our S3 bucket with proper organization and metadata.\nCreate Lambda Function Navigate to the Lambda console and start function creation. Configure the function with Node.js runtime and existing IAM role. Set up the function name and basic execution settings. Implement Data Collection Code Access the Lambda function code editor. Replace the default code with data collection logic. Configure S3 integration for organized data storage with partitioning. "
},
{
	"uri": "http://localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]